\documentclass[12pt]{article}

% Packages
\usepackage[margin=1.2in]{geometry}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{colortbl}
\usepackage{listings}
\usepackage{titling}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{caption}
\usepackage{array}
\captionsetup[table]{skip=2pt}
% Comments --------------------------------------------------------------------
\usepackage{xcolor}
\newif\ifcomments\commentstrue
\ifcomments \newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}} \else
\newcommand{\authornote}[3]{} \newcommand{\todo}[1]{} \fi
\newcommand{\wss}[1]{\authornote{magenta}{SS}{#1}}
\newcommand{\ds}[1]{\authornote{blue}{DS}{#1}}
% End Comments ---------------------------------------------------------------
\setlength{\parindent}{0pt}

% Title Page -----------------------------------------------------------------
\title{
\LARGE GEANT-4 GPU Port:
\\\vspace{10mm}
\large \textbf{Design Document: System Architecture}
\vspace{40mm}
}
\author{
\textbf{Team 8}
\\Stuart Douglas -- dougls2
\\Matthew Pagnan -- pagnanmm
\\Rob Gorrie -- gorrierw
\\Victor Reginato -- reginavp
\vspace{10mm}
}
\date{\vfill \textbf{System Architecture: Version 0}\\ \today}
% End Title Page -------------------------------------------------------------

% ============================== BEGIN DOCUMENT ============================= %
\begin{document}
\pagenumbering{gobble} % start numbering after TOC

% ============================== Title Page ============================= %
\maketitle
\newpage

% ================================= TOC ================================= %
\renewcommand{\contentsname}{Table of Contents}
\tableofcontents
\newpage
\pagenumbering{arabic}

\section{Introduction}% ============== Matt
\subsection{Revision History}
All major edits to this document will be recorded in the table below.

\begin{table}[h]
\centering
\caption{Revision History}\label{Table_Revision}
\begin{tabularx}{\textwidth}{Xll}
\toprule
\bf Description of Changes & \bf Author & \bf Date\\\midrule
Set up sections and filled out Introduction section & Matthew & 2015-12-15\\
Document structure adjustments & Stuart & 2016-1-8\\
Filled out Likely/Unlikely Changes section & Rob & 2016-1-9\\
\bottomrule
\end{tabularx}
\end{table}

\subsection{Terms Used}
\begin{table}[h]
\centering
\caption{Glossary}\label{Table_Glossary}
\begin{tabularx}{\textwidth}{lX}
\toprule
\bf Term & \bf Description\\\midrule\vspace{1mm}
Geant4 & open-source software toolkit for simulating particle interactions\\\vspace{1mm}
G4-STORK & fork of Geant4 developed by McMaster's Engineering Physics department to simulate McMaster's nuclear reactor\\\vspace{1mm}
GPU & graphics processing unit, well-suited to parallel computing tasks\\\vspace{1mm}
CPU & computer processing unit, well-suited to serial tasks\\\vspace{1mm}
CUDA & parallel computing architecture for GPU programming, developed by NVIDIA\\\vspace{1mm}
CUDA file & text file with .cu extension that includes host code (which runs on the CPU) and device code (which runs on the GPU)\\\vspace{1mm}
NVIDIA & computer hardware and software company specializing in GPU's\\\vspace{1mm}
Host & the CPU and its memory, managed from within a CUDA file, sends and receives data to the GPU\\\vspace{1mm}
Device & the GPU and its memory, managed from the host, performs computations requested by the host\\
\bottomrule
\end{tabularx}
\end{table}

\subsection{List of Tables}
\begin{center}
\begin{tabular}{cl}
\toprule
\bf Table \# & \bf Title\\\midrule
\ref{Table_Revision} & Revision History\\
\ref{Table_Glossary} & Glossary\\
\ref{Table_RequirementsAndDesign} & Traceability of Requirements and Design\\
\bottomrule
\end{tabular}
\end{center}

\subsection{List of Figures}
\begin{center}
\begin{tabular}{cl}
\toprule
\bf Figure \# & \bf Title\\\midrule
\ref{imgUsesHierarchy} & Uses Hierarchy for G4NeutronHPVector\\
\bottomrule
\end{tabular}
\end{center}

\section{Overview}
\subsection{Purpose of Project}
The purpose of the project is to reduce the computation times of particle simulations in Geant4 by parallelizing and running certain procedures on the GPU.

\subsection{Description}
The project aims to improve the computation times of Geant4 particle simulations by running certain parallel operations on a GPU. GEANT4-GPU will be a fork of the existing Geant4 system with the additional option for users with compatible hardware to run operations on the GPU for improved performane. This functionality will be available on Mac, Linux and Windows operating systems running on computers with NVIDIA graphics cards that support CUDA.\\

The design strategy for the project will be based on taking a specific, computationally heavy class from Geant4 and creating a class that fulfills the same interface but that runs on the GPU. This will be repeated for many classes until the project's deadline has been reached. The user will have the option of using the existing classes (running on the CPU) or the new ones (running on the GPU).

\subsection{Document Structure \& Template}
The design documentation for the project is based off of WHAT TEMPLATES?????? and is broken into two main documents.\\

This system architecture document details the system architecture, including an overview of the modules that make up the system, analysis of aspects that are likely and unlikely to change, reasoning behind the high-level decisions, and a table showing how each requirement is addressed in the proposed design.\\

A separate detailed design document covers the specifics of several key modules in the project. This includes the interface specification and implementation decisions.

\section{Important Design Decisions \& Reasoning}
\subsection{GPU Computing for Geant4}
Geant4 simulations typically involve simulating the movement of many particles (up to millions). Each particle moves independently of the other particles. Currently, the particles are all stored in an array that the CPU has to go through moving each particle one by one. Considering how many particles this array holds this is a rather time consuming operation, especially since this movement of the particles is done often. 
Due to the nature of the particles being able to move independently of each other this is a problem that can be easily parallelized. Since the act of moving a particle is so simple GPU cores are able to execute these types of functions. So instead of parallelizing Geant4 on multiple CPU's we can instead parallelize the code to run on all the GPU cores since the GPU has many more cores than the CPU it is able to run the parallelized code much faster.

\subsection{CUDA}
NVIDA recently created a toolkit to make creating parallel code on the GPU much easier. Due to how accessible and easy to use CUDA is to parallelize existing code CUDA was chosen to be as the architecture to be used for this project as it would require the least amount of understanding of the existing Geant4 functions to produce speedups. 

\subsection{GPU Integration Approach} % stu
When considering how to integrate the GPU computations with the non-ported procedures that run on the CPU there were five main options (option 5 was chosen):
\begin{enumerate}
\item Port entire Geant4 toolkit to fully run on the GPU.
\item Port all functions of some classes to run on the GPU, those classes will only be instantiated in GPU memory.
\item Port some functions of some classes to run on the GPU, those classes will be stored only in main memory. Data required by the GPU functions will be passed from the host.
\item Port some functions of some classes to run on the GPU, those classes will be stored in main memory and a copy will be stored in GPU memory. Updates to the state will be applied to both copies.
\item Port some functions of some classes to run on the GPU, those classes will have some data stored in main memory and some (different) data stored in GPU memory. If data is required by a function running on the CPU that is stored on the GPU (or vice versa), a copy of the data will be received through a getter function.
\end{enumerate}

\begin{center}
\begin{tabularx}{\textwidth}{cXX}
\toprule
\bf Option & \bf Pros & \bf Cons\\\midrule
\arrayrulecolor{lightgray}

1 & \textbullet $\,$ largest speedup as all aspects of system would be parallelized
  & \textbullet $\,$ far beyond scope of project and resources available\\\hline

2 & \textbullet $\,$ no memory usage penalty as class only instantiated once\newline
    \textbullet $\,$ no performance penalty for passing data from main memory to GPU memory
  & \textbullet $\,$ difficult to use existing code if GPU computation disabled\newline
    \textbullet $\,$ requires porting all functions of class to GPU even if functions won't give large performance benefits\newline
    \textbullet $\,$ smaller memory available for GPU may mean that less particles can be simulated at once\\\hline

3 & \textbullet $\,$ no memory usage penalty as class only instantiated once\newline
    \textbullet $\,$ easily interfaces with existing codebase\newline
    \textbullet $\,$ easy to use existing code if GPU computation disabled\newline
    \textbullet $\,$ doesn't require porting functions to GPU that will not have large performance benefits
  & \textbullet $\,$ all data must be passed from main memory to GPU memory every function call\\\hline

4 & \textbullet $\,$ no performance penalty for passing data between main memory and GPU memory\newline
    \textbullet $\,$ easily interfaces with existing codebase\newline
    \textbullet $\,$ easy to use existing code if GPU computation disabled\newline
    \textbullet $\,$ doesn't require porting functions to GPU that will not have large performance benefits
  & \textbullet $\,$ double the memory usage\newline
    \textbullet $\,$ smaller memory available for GPU may mean that less particles can be simulated at once\newline
    \textbullet $\,$ everytime state updated it must be updated twice\\\hline

5 & \textbullet $\,$ reduced performance penalty for passing data between main memory and GPU memory\newline
    \textbullet $\,$ easy to use existing code if GPU computation disabled\newline
    \textbullet $\,$ easily interfaces with existing codebase\newline
    \textbullet $\,$ doesn't require porting functions to GPU that will not have large performance benefits
  & \textbullet $\,$ performance penalty if data required by CPU from GPU memory (or vice versa)\\

\arrayrulecolor{black}
\bottomrule
\end{tabularx}
\end{center}

In all options except 1 and 2, a function call to one of the functions of a ported class will be received by the existing C++ class, which will then either execute the existing code if that function has not been ported or if GPU computation is disabled, or will call the corresponding function from the CUDA file.\\

Option 5 was chosen due to its ability to divide work easily, its compatibility with the current codebase, and the memory advantages over option 4.

\subsection{G4NeutronHPVector}\label{subsec_G4NeutronHPVector} % rob

\section{Likely and Unlikely Changes}
The following two subsections outline proposed changes or additions to the design and structure of the system. They are seperated into two categories; those likely to be implemented and those unlikely. These are changes that would be implemented following the initial version release. Relative likely-hood of implementations in the same category may vary. \\
The subection following the two previously mentioned contains a traceability matrix tracking the changes to their corresponding design components.

\subsection{Likely Changes} %========== Rob
\begin{enumerate}
\item Implementing OpenACC to compare performance increase
\item Parallelizing several other process modules
\item Inclusion of a script to detect if user has a Cuda capable GPU during Geant4 building
\item Cuda installation guide addition to README
\item README revamp to distinguish between Geant4 and Stork instructions
\item Parallelizing of additional subroutines which indicate performance bottlenecks
\item Compilation and installation process
\item Geant4/Cuda guide to help practitioners implement GPGPU techniques on processes and modules for their own use
\item Benchmarking guide for users of the product
\end{enumerate}

\subsection{Unlikely Changes} %========= Rob
\begin{enumerate}
\item Changes to any data structures or algorithms native to the Geant4 codebase
\item Full switch to OpenACC
\item GPGPU computations on a broad scope within Geant4
\item Addition of any new process or model modules to Geant4
\end{enumerate}

\subsection{Traceability of Likely Changes to Design Components}

\section{Module Hierarchy}%============= Stuart
\subsection{Decomposition of Components}
The project is based off of Geant4, an existing software system, and modifying specific modules of that system. As such, the decomposition used by the existing system will match the modules of the new system in the project development.\\

Each module in Geant4 is represented by a C++ class, and the project will port a subset of said classes to the GPU. The decision of which classes to port is derived from performance analysis of the program, with the most computationally time-consuming classes being the targets, such as G4NeutronHPVector (see section \ref{subsec_G4NeutronHPVector}). Furthermore, it is possible that not all functions of the class will be ported. The focus will be on porting ``clean'' (having a limited number of side effects), computationally heavy functions. This allows the work to be broken down on a class-by-class and function-by-function basis, and completing the port of one class does not depend on any other classes being ported. If a function running on the GPU requires an external module, the C++ host code for the CUDA that interfaces with the GPU will extract and pass any required information to the GPU and perform any state updates.

\subsection{Uses Hierarchy}
Since each modified module of the project will have a direct 1-to-1 relationship with an existing module in Geant4, the uses hierarchy with the new, GPU-enabled classes will be identical to the existing uses hierarchy of Geant4 with their corresponding existing classes.\\

Geant4 is an extremely large system with many modules, so its entire uses hierarchy will not be documented here. Instead, the following hierarchy shows the dependencies of the G4NeutronHPVector module, which is currently the focus of the project. Note that modules used by system libraries are not included, but the system libraries themselves are included.
\begin{figure}[h]
\caption{Uses Hierarchy for G4NeutronHPVector}\label{imgUsesHierarchy}
\includegraphics[width=\textwidth]{uses_hierarchy.pdf}
\end{figure}

\section{Traceability of Requirements and Design Components}% ===== Stuart
The following section outlines each requirement and its relationship to the design.

\begin{table}[h]
\centering
\caption{Requirements and Design Relationship}\label{Table_RequirementsAndDesign}
\begin{tabularx}{\textwidth}{cXX}

\toprule
\bf Req. & \bf Brief Description & \bf Design Component\\\midrule
\arrayrulecolor{lightgray}
1  & computations run on GPU & entire document\\\hline
2  & existing projects not affected & \\\hline
3  & by default simulation will run on CPU & \\\hline
4  & should detect if computer has compatible GPU & \\\hline
5  & enabling GPU computation on incompatible hardware not allowed & \\\hline
6  & enabling GPU functionality on existing projects easy & \\\hline
7 & runtime of simulation decreased with same output & \\\hline
8 & accuracy of results same as when run on CPU & \\\hline
9 & at least as stable as existing system & \\\hline
10 & errors will throw exceptions & \\\hline
11 & will support Geant4 10.00.p02 and later & \\\hline
12 & available on public repo with installation instructions & \\\hline
13 & new versions of product will be available on repo, won't break previous features & \\\hline
14 & all users have access to entire product & \\
\arrayrulecolor{black}
\bottomrule
\end{tabularx}
\end{table}

\end{document}
