\documentclass[12pt]{article}

% Packages
\usepackage[margin=1.2in]{geometry}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{titling}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage{caption}
\usepackage{array}

\usepackage{placeins}
\usepackage{float}
\usepackage{multirow}
\captionsetup[table]{skip=2pt}
% Comments --------------------------------------------------------------------
\usepackage{xcolor}
\newif\ifcomments\commentstrue
\ifcomments \newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}} \else
\newcommand{\authornote}[3]{} \newcommand{\todo}[1]{} \fi
\newcommand{\wss}[1]{\authornote{magenta}{SS}{#1}}
\newcommand{\ds}[1]{\authornote{blue}{DS}{#1}}
\newcommand{\mmp}[1]{\authornote{green}{MP}{#1}}
% End Comments ---------------------------------------------------------------

\setlength\parindent{0pt} % Cleaner look


\newcounter{RiskNumCounter}
\setcounter{RiskNumCounter}{0}
\newcounter{TestCounter}
\setcounter{TestCounter}{0}


% Title Page -----------------------------------------------------------------
\title{
\LARGE GEANT-4 GPU Port:
\\\vspace{10mm}
\large \textbf{Test Plan}
\vspace{40mm}
}
\author{
Stuart Douglas -- dougls2
\\Matthew Pagnan -- pagnanmm
\\Rob Gorrie -- gorrierw
\\Victor Reginato -- reginavp
\vspace{10mm}
}
\date{\vfill \textbf{Version 0}\\ \today}
% End Title Page -------------------------------------------------------------

% ============================== BEGIN DOCUMENT ============================= %
\begin{document}
\pagenumbering{gobble} % start numbering after TOC

% ============================== Title Page ============================= %
\maketitle
\newpage

% ================================= TOC ================================= %
\newgeometry{bottom=1.1in, top=1.1in}
\tableofcontents
\newpage
\pagenumbering{arabic}
\restoregeometry


% =============================== Section =============================== %
\section*{Revision History}
All major edits to this document will be recorded in the table below.

\begin{table}[h]
\centering
\caption{Revision History}\label{Table_Revision}
\begin{tabular}{lll}

\toprule
\bf Description of Changes & \bf Author & \bf Date\\\midrule
Changes for rev0 presentation & Matt & 2016-02-08\\
Added Test Schedule Table & Stuart & 2015-10-30\\
Reformatted Tables & Matthew & 2015-10-30\\
Added System test cases & Matthew & 2015-10-29\\
Initial draft of document & Stuart, Matthew, Rob, Victor & 2015-10-26\\

\bottomrule
\end{tabular}
\end{table}

% =============================== Section =============================== %
\section*{List of Tables}

\begin{center}
\begin{tabular}{cl}
\toprule

\bf Table \# & \bf Title\\\midrule
\ref{Table_Revision} & Revision History\\
\ref{Table_Risks} & Risks\\
\ref{Table_Acronyms} & Definitions and Acronyms\\
\ref{Table_References} & References\\
\ref{Table_SystemTests} & System Tests\\
%\ref{Table_UnitTestsTimes} & Unit Tests - \emph{Times} function\\
%\ref{Table_UnitTestsPlus} & Unit Tests - $+$ function\\
\ref{Table_RequirementsTests} & Requirements Tests\\
\ref{Table_TestFactors} & Test Factors\\
\ref{Table_Schedule} & Testing Schedule\\
\ref{Table_Deliverables} & Timeline of Deliverables\\

\bottomrule
\end{tabular}
\end{center}


% =============================== Section =============================== %
\section{General Information}

% ----------------------------- Sub Section ----------------------------- %
\subsection{Summary} % Matt
The product, GEANT4-GPU, will be a modified version of G4-STORK that will leverage GPU computing to increase performance while still outputting the same results as the existing, CPU-based G4-STORK project. This testing plan outlines how the development team is expected to test the correctness and performance of the product through the use of unit testing, system testing, and code testing.
\newpage
% ----------------------------- Sub Section ----------------------------- %
\subsection{Risks} % Stuart
The following table outlines the major risks associated with the testing of the product. A more detailed analysis of each of the risks follows the table.

\begin{center}
\begin{longtable}{>{\raggedright\arraybackslash}p{0.1\textwidth}>{\raggedright\arraybackslash}p{0.6\textwidth}>{\raggedright\arraybackslash}p{0.2\textwidth}}
\caption{Risks}\label{Table_Risks}\\
\toprule

\textbf{Risk \#} & \textbf{Summary} & \textbf{Severity}\\\midrule

\refstepcounter{RiskNumCounter} \arabic{RiskNumCounter} \label{R_RandNums} 
& differing order of random numbers on GPU could lead to difficulty comparing results with simulations run on CPU 
& Very High\\

\refstepcounter{RiskNumCounter} \arabic{RiskNumCounter} \label{R_IsolateFunctions} 
& isolating GEANT4 methods to test with unit tests may be too difficult 
& High\\

\refstepcounter{RiskNumCounter} \arabic{RiskNumCounter} \label{R_Time} 
& running time of tests will be too long to run them frequently 
& High\\

\bottomrule\\
\end{longtable}
\end{center}

\textbf{Risk \ref{R_RandNums} -- Random Numbers}:\\
The GEANT4 project is heavily dependent on random numbers. Random numbers are used to determine attributes about particles (independent of all other particles) as they move through the system. By parallelizing the workload, the order in which the particles are evaluated may change, causing it to draw a different random number from the sequence, leading to different results. If it is decided to generate the random numbers using GPU API calls, then they will certainly be different than in the serial, CPU version of the software.\\

Two solutions to this problem have been discussed. The first is to develop a solution to pass the CPU-generated numbers to the GPU while ensuring they remain in sync to the order they would be received in the serial version. This would require extra development work, but would ensure that testing the product against the existing system can be done in a straight-forward manner. The alternative is to test the software based on degree of similarity between single points of summarizing data (e.g. a mean). Comparing the products in this manner would have the developers check that the results are within a given margin of error, and if so the product would be deemed correct. This is the solution that is planning on being implemented at this point, however if it does not seem feasible during the design and development phases the developers are open to exploring solution one.\\
\newpage
\textbf{Risk \ref{R_IsolateFunctions} -- Isolating Functions}:\\
The codebase of GEANT4 is large and complex, a potential testing risk would be that the functions to be parallelized are not well-enough isolated to easily test inputs and outputs. The objects used in GEANT4's calculations are large and often dependent on other objects. To mitigate this testing risk, development will focus on porting single functions in classes to be tested, and unit testing will test those specific functions.\\

\textbf{Risk \ref{R_Time} -- Test Runtime}\\
Running a full system test on the modified code is a computationally intensive procedure. Even with a relatively small number of particles the computation could take several hours. With a larger, more realistic number of particles, running the program could take on the order of days. This would prevent frequent system testing, and the team would have to rely on unit tests during development. To address this risk, relatively simple examples will be used for most system tests (i.e. with few particles) and they will be run tests regularly along with unit tests. After large changes, more complex system tests will be run to ensure that the correctness has not been affected when using larger, more realistic examples.

% ----------------------------- Sub Section ----------------------------- %
\subsection{Constraints} % Victor
Time is one of the largest constraints, the completed project is due next April, which is 6 months from the initial revision of this document. In order to perform rigorous testing on all functions, classes, and sections of code that have been parallelized, a  large amount of time is required. GEANT4 is a large library with many different objects and functions, with each section contributing to the overall performance. Each addition of a control branch to the code must be tested to ensure that the original functionality is preserved. Maximizing performance while minimizing changes to the actual code should help to deal with the time constraint.
\newpage
% ----------------------------- Sub Section ----------------------------- %
\subsection{Definitions and Acronyms} % Rob
\begin{center}
\begin{longtable}{>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.65\textwidth}}
\caption{Definitions and Acronyms}\label{Table_Acronyms}\\
\toprule

\bf Acronym & \bf Definition\\\midrule
GEANT-4 & open-source software toolkit used to simulate the passage of particles through matter\\\midrule
G4-STORK & (Geant-4 STOchastic Reactor Kinetics), fork of GEANT-4 developed by McMaster's Engineering Physics department to simulate McMaster's nuclear reactor\\\midrule
GPU & graphics processing unit, well-suited to parallel computing tasks\\\midrule
CPU & computer (central) processing unit, general computer processor well suited to serial tasks\\\midrule
GP-GPU & concept of running "general purpose" computations on the GPU\\\midrule
CUDA & parallel computing architecture for general purpose programming on GPU, developed by NVIDIA\\\midrule
PoC & proof of concept\\\midrule
SRS & software requirements specification\\

\bottomrule
\end{longtable}
\end{center}

% ----------------------------- Sub Section ----------------------------- %
\subsection{References}% Victor
The following documents are referenced within this test plan.

\begin{center}
\begin{longtable}{>{\raggedright\arraybackslash}p{0.2\textwidth}>{\raggedright\arraybackslash}p{0.3\textwidth}>{\raggedright\arraybackslash}p{0.35\textwidth}}
\caption{Referenced Documents}\label{Table_References}\\
\toprule

\bf Title & \bf Author(s) & \bf Description\\\midrule
GEANT-4 GPU Port: SRS & Stuart, Matthew, Rob, Victor & Requirements specification for the project\\\midrule
PoC Plan for GEANT4-GPU & Stuart, Matthew, Rob, Victor & Demonstration details for product's Proof of Concept\\\midrule
UniNotesTestPlan & Umar Khan, Ashwin Samtani, Olakotumbo Agia & Test plan outline/framework\\

\bottomrule
\end{longtable}
\end{center}
% =============================== Section =============================== %
\section{Test Types}

% ----------------------------- Sub Section ----------------------------- %
\subsection{System Testing} % Matt
There are several examples included with the GEANT4 toolkit as well as some created by McMaster's Engineering Physics department for G4-STORK. Examples in GEANT4 will be used for system testing. Due to the computation time for some of the examples, they will be run less frequently than the simpler ones. This will let the developers run system tests regularly on the simple files, while checking that more realistic, complex examples are also correct after bigger changes.

\begin{center}
\begin{longtable}{cc >{\raggedright\arraybackslash}p{2.8cm}>{\raggedright\arraybackslash}p{3cm}>{\raggedright\arraybackslash}p{4.5cm}}
\caption{System Tests}\label{Table_SystemTests}\\
\toprule

\bf \# & \bf Initial State & \bf Inputs & \bf Outputs & \bf Description\\\midrule
\stepcounter{TestCounter}\arabic{TestCounter} 
& Fresh start up 
& Events = 2000
Material = Water
& Same output as non-GPU GEANT4 
&  HADR04 no changes\\\midrule

\stepcounter{TestCounter}\arabic{TestCounter}
& Fresh start up 
& Events = 2000
Material = Uranium
& Same output as non-GPU GEANT4 
& HADR04 -- basic example\\\midrule

\stepcounter{TestCounter}\arabic{TestCounter}
& Fresh start up 
& Events = 600
Material = Water
& Same output as non-GPU GEANT4 
& HADR04 -- Shorter test \\\midrule

\stepcounter{TestCounter}\arabic{TestCounter}
& Fresh start up 
& Events = 600
Material = Uranium
& Same output as non-GPU GEANT4 
& HADR04 -- Shorter test \\\midrule

\stepcounter{TestCounter}\arabic{TestCounter}
& Fresh start up 
& Events = 20000
Material = Uranium
& Same output as non-GPU GEANT4 
& HADR04 -- Long simulation stress Test\\\midrule

%\stepcounter{TestCounter}\arabic{TestCounter}
%& Fresh start up 
%& Events = 0
%Material = Uranium
%& Same output as non-GPU GEANT4 
%& HADR04 -- no runs,  Edge case\\

%\stepcounter{TestCounter}\arabic{TestCounter}
%& Fresh start up 
%& Events = 60
%Particles = 20
%& Same output as non-GPU G4STORK 
%& HADR04 -- Long simulation\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter}
%& Fresh start up 
%& Events = 12
%Particles = 2
%& Same output as non-GPU G4STORK 
%& SCWRDopplerInput.txt -- Few Particles\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter}
%& Fresh start up 
%& Events = 12
%Particles = 2000
%& Same output as non-GPU G4STORK 
%& SCWRDopplerInput.txt -- Many Particles\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& Fresh start up 
%& Events = 2
%Particles = 2
%& Same output as non-GPU G4STORK 
%&  SCWRDopplerInput.txt  -- Minimum stress\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& Fresh start up 
%& Events = 60
%Particles = 2000
%& Same output as non-GPU G4STORK 
%&  SCWRDopplerInput.txt  -- Stress test\\

\bottomrule
\end{longtable}
\end{center}
\mmp{Not using G4-STORK for system tests - therefore had to change system tests}
% ----------------------------- Sub Section ----------------------------- %
\section{Unit Testing}
\subsection{Use of Automated Testing}
\subsubsection{Overview}
Our unit testing system is semi-automated. The user runs a program to generate a test results text file, inputting whether or not Geant4 was compiled with CUDA enabled or disabled. Then, they recompile Geant4 in the opposite configuration (i.e. with CUDA enabled if previously disabled, and vice versa) and run the test program again. At this point there will be two test results text files, one for CUDA enabled, and one for CUDA disabled. In addition, two text files containing runtimes of all computationally-intensive functions are produced. After generating the files, a program to analyze the results is run outputting whether each test case passed or failed, and creating an Excel document (.csv) with the running times.

\subsubsection{Generating Test Results}
\texttt{GenerateTestResults} first initializes several G4ParticleHPVector objects from data files included with Geant4 of varying numbers of entries, including the creation of one G4ParticleHPVector with 0 entries. After the vectors have been initialized, the unit-tested methods are tested with a variety of input values. These cover edge cases (i.e. negative index for array, index greater than number of elements etc.) as well as more ``normal'' cases. The result of each function is then written to the results text file. This can be a single value in the case of ``clean'' functions that simply return a value, or it could be the state of the G4ParticleHPVector object, that is the array of points stored by that object. For performance reasons, instead of writing out the entire array of points, a hash value is generated from the array and is outputted. The value of the input variable for each function call is also outputted, so the results for specific inputs can be analyzed.

\subsubsection{Analyzing Test Results}
After the above files are generated, the \texttt{AnalyzeTestResults} utility runs through both documents and for each unit test outputted its status. If it failed, then the result from the CPU and from the GPU are both printed out. After the analysis completes, the total number of tests passed is outputted. In addition, \texttt{AnalyzeTestResults} will read the files containing runtimes for each function and output them in .csv format to simplify performance analysis.

\subsubsection{Note About Random Results}
Some of the tests run in \texttt{GenerateTestResults} are based off of random numbers, which differ between the CPU and GPU implementations. To counteract this, each of those tests is run multiple times and the result is averaged. When analyzing results for those functions, they are only marked as failed if the difference in the values of the GPU and CPU results are more than a specified tolerance. There are some functions that depend on random numbers that modify the data array. Since a hash is outputted and will differ no matter how small the difference in the values of the array are, before hashing the values are all rounded to a lower precision.

\subsection{Definition of Variables Used for Unit Testing}
The following are variables that are used for multiple unit tests. Instead of defining them again for each unit test they are defined here only once. Other variables used for specific unit tests will be defined in their respective unit test sections\\
For all unit tests:
\begin{table}[H]
\centering
\caption{General Unit Test Variables}\label{gen_var_table}
\begin{tabular}{lll}
\toprule
	\bf Name & \bf Type & \bf Description\\\midrule
	n 	& G4double 			& number of entries in the G4ParticleHPVector\\
	r1 	& G4double 			& -1.0\\
	r2	& G4double			& 0.0\\
	r3 	& G4double 			& 0.00051234\\
	r4 	& G4double 			& 1.5892317\\
	r5 	& G4double 			& 513.18\\
	vec0 & G4ParticleHPVector 	& 0 entries\\
	vec1 & G4ParticleHPVector	& 80 entries\\
	vec2 & G4ParticleHPVector 	& 1509 entries\\
	vec3 & G4ParticleHPVector 	& 8045 entries\\
	vec4 & G4ParticleHPVector 	& 41854 entries\\
	vec5 & G4ParticleHPVector 	& 98995 entries\\
	vec6 & G4ParticleHPVector 	& 242594 entries\\
\bottomrule		
\end{tabular}
\end{table}

\ds{What unit testing framework are you planning to use?} \mmp{Mentioned that we will be making our own unit testing framework}

\subsection{G4ParticleHPVector \& operator = (const G4ParticleHPVector \& right)}
	\subsubsection{Test Description}
	Create a new, temporary G4ParticleHPVector object and assign the current vector to it. Outputs the data and the integral from the new vector.

	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{=} (overloaded assignment operator)}\label{OperatorEquals_unit}
		\begin{tabular}{cl}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{right}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{OperatorEquals_0} & Current vector\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{const G4ParticleHPDataPoint GetPoint(G4int i)}
	\subsubsection{Test Description}
	Returns the G4ParticleHPDataPoint at index \texttt{i} in the current vector. The \texttt{x} 
	and \texttt{y} values of the point are outputted.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{GetPoint}}\label{GetPoint_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{i}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetPoint_0} & -1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetPoint_1} & 0\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetPoint_2} & n/2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetPoint_3} & n-1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetPoint_4} & n\\
		\bottomrule
		\end{tabular}
		\end{table}
		
\subsection{G4double GetX(G4int i)}
	\subsubsection{Test Description}
	Returns the energy at index \texttt{i} in the current vector. The \texttt{x} 
	value of the point are outputted.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{GetX}}\label{GetX_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{i}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetX_0} & -1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetX_1} & 0\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetX_2} & n/2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetX_3} & n-1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetX_4} & n\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double GetY(G4int i)}

	\subsubsection{Test Description}
	Returns the xSec at index \texttt{i} in the current vector. The \texttt{y} 
	value of the point are outputted.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{GetY}}\label{GetY_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{i}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetY_0} & -1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetY_1} & 0\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetY_2} & n/2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetY_3} & n-1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetY_4} & n\\
		\bottomrule
		\end{tabular}
\end{table}

\subsection{G4double GetXsec(G4int i)} % Test cases finished
	\subsubsection{Test Description}
	Returns the xSec at index \texttt{i} in the current vector. The \texttt{y} 
	value of the point are outputted.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{GetXsec}}\label{GetXsec_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{i}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_0} & -1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_1} & 0\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_2} & n/2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_3} & n-1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_4} & n\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double GetEnergy(G4int i)} % Test cases finished
	\subsubsection{Test Description}
	Returns the energy at index \texttt{i} in the current vector. The \texttt{x} 
	value of the point are outputted.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{GetEnergy}}\label{GetEnergy_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{i}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetEnergy_0} & -1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetEnergy_1} & 0\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetEnergy_2} & n/2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetEnergy_3} & n-1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetEnergy_4} & n\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void SetData(G4int i, G4double x, G4double y)}
	\subsubsection{Test Description}
	Sets the energy and xSec at index \texttt{i} in the current vector. 
	
	\subsubsection{Test Inputs}
	Commas denote multiple sub test inputs. If one of the sub tests fail then the whole test fails.
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{SetData}}\label{SetData_unit}
		\begin{tabular}{lllll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{3}{c}{\bf Inputs}\\
		& \bf \texttt{i} & \bf \texttt{x} & \bf \texttt{y}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetData_0} & -1 & r1, r2, r3, r4, r5 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetData_1} & 0 & r1, r2, r3, r4, r5 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetData_2} & n/2 & r1, r2, r3, r4, r5 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetData_3} & n-1 & r1, r2, r3, r4, r5 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetData_4} & n & r1, r2, r3, r4, r5 & r1, r2, r3, r4, r5\\
		\bottomrule
		\end{tabular}
		\end{table}


\subsection{void SetEnergy(G4int i, G4double e)}
	\subsubsection{Test Description}
	Sets the energy at index \texttt{i} in the current vector. 
	
	\subsubsection{Test Inputs}
	Commas denote multiple sub test inputs. If one of the sub tests fail then the whole test fails.
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{SetEnergy}}\label{SetEnergy_unit}
		\begin{tabular}{llll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{2}{c}{\bf Inputs}\\
		& \bf \texttt{i} & \bf \texttt{e}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetEnergy_0} & -1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetEnergy_1} & 0 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetEnergy_2} & n/2 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetEnergy_3} & n-1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetEnergy_4} & n & r1, r2, r3, r4, r5\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void SetXsec(G4int i, G4double e)} % Test cases finished
	\subsubsection{Test Description}
	Sets the xSec at index \texttt{i} in the current vector. 
	
	\subsubsection{Test Inputs}
	Commas denote multiple sub test inputs. If one of the sub tests fail then the whole test fails.
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{SetXsec}}\label{SetXsec_unit}
		\begin{tabular}{llll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{2}{c}{\bf Inputs}\\
		& \bf \texttt{i} & \bf \texttt{e}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetXsec_0} & -1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetXsec_1} & 0 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetXsec_2} & n/2 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetXsec_3} & n-1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetXsec_4} & n & r1, r2, r3, r4, r5\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void SetX(G4int i, G4double e)} % Test cases finished
	\subsubsection{Test Description}
	Sets the energy at index \texttt{i} in the current vector. 
	
	\subsubsection{Test Inputs}
	Commas denote multiple sub test inputs. If one of the sub tests fail then the whole test fails.
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{SetX}}\label{SetX_unit}
		\begin{tabular}{llll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{2}{c}{\bf Inputs}\\
		& \bf \texttt{i} & \bf \texttt{e}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetX_0} & -1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetX_1} & 0 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetX_2} & n/2 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetX_3} & n-1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetX_4} & n & r1, r2, r3, r4, r5\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void SetY(G4int i, G4double e)} % Test cases finished
	\subsubsection{Test Description}
	Sets the xSec at index \texttt{i} in the current vector. 
	
	\subsubsection{Test Inputs}
	Commas denote multiple sub test inputs. If one of the sub tests fail then the whole test fails.
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{SetY}}\label{SetY_unit}
		\begin{tabular}{llll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{2}{c}{\bf Inputs}\\
		& \bf \texttt{i} & \bf \texttt{e}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetY_0} & -1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetY_1} & 0 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetY_2} & n/2 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetY_3} & n-1 & r1, r2, r3, r4, r5\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetY_4} & n & r1, r2, r3, r4, r5\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void Init(istream \& aDataFile, G4int total, G4double ux, G4double uy)} 
	\subsubsection{Test Description}
	Initializes the data.	

	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{Init}}\label{Init_unit}
		\begin{tabular}{lllll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{4}{c}{\bf Inputs}\\
		& \bf \texttt{aDataFile} & \bf \texttt{G4int} & \bf \texttt{ux} & \bf \texttt{uy}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Init_0} & Empty.Init() & n & 1 & 1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Init_1} & D.Init() & n & 1 & 1\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double SampleLin()}% Test Cases Done
	\subsubsection{Test Description}
	 Performs samples of the vector with a linear interpolation scheme.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{SampleLin}}\label{SampleLin_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{N/A}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SampleLin_0} & N/A \\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void Times(G4double factor)} % Test Cases done
	\subsubsection{Test Description}
	Multiplies every element in the vector by \texttt{factor}.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{Times}}\label{Times_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{factor}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Times_0} & r1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Times_1} & r2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Times_2} & r3\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Times_3} & r4\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Times_4} & r5\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void ThinOut(G4double precision)} % Test Cases done 
	\subsubsection{Test Description}
	Removes any element from the vector whose neighbor is closer than \texttt{precision}.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{ThinOut}}\label{ThinOut_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{factor}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{ThinOut_0} & r1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{ThinOut_1} & r2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{ThinOut_2} & r3\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{ThinOut_3} & r4\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{ThinOut_4} & r5\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double Sample()}% Test Cases Done
	\subsubsection{Test Description}
	  Performs samples of the vector according to interpolation its interpolation scheme.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{Sample}}\label{Sample_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{N/A}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Sample_0} & N/A \\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{void SetPoint(G4int i, const G4ParticleHPDataPoint \& it)}
	\subsubsection{Test Description}
	Sets a point at a given index in a given vector.

	\subsubsection{Test Inputs}
		\begin{itemize}
			\item ``rPoint" is a random G4ParticleHPDataPoint
			\item ``nPoint" is a negative G4ParticleHPDataPoint
			\item ``zPoint" is a zero G4ParticleHPDataPoint
		\end{itemize}
		\begin{table}[H]
		\centering
		\caption{Unit Tests}\label{SetPoint_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#} & \multicolumn{2}{c}{\bf Inputs}\\
		& vec0 & vec1\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_0} & -1 & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_1} & 0 & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_2} & 1 & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_3} & -1 & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_4} & 0 & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_5} & n/2 & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_6} & n-1 & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_7} & n & rPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_8} & 0 & nPoint\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{SetPoint_9} & 0 & zPoint\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double GetXsec(G4double e)} % Test cases finished
	\subsubsection{Test Description}
	Returns the first xSec from the current vector whose energy is greater than \texttt{e}. 
	
	\subsubsection{Test Inputs}
	Commas denote multiple sub test inputs. If one of the sub tests fail then the whole test fails.
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{GetXsec}}\label{GetXsec_e_unit}
		\begin{tabular}{llll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{e}  \\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_0} & r1, r2, r3, r4, r5 \\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_1} & r1, r2, r3, r4, r5 \\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_2} & r1, r2, r3, r4, r5 \\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_3} & r1, r2, r3, r4, r5 \\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_4} & r1, r2, r3, r4, r5 \\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double GetXsec(G4double e, G4int min)}
	\subsubsection{Test Description}
	Returns the first xSec from the current vector whose energy is greater than \texttt{e}. 
	
	\subsubsection{Test Inputs}
	Commas denote multiple sub test inputs. If one of the sub tests fail then the whole test fails.
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{GetXsec}}\label{GetXsec_e_min_unit}
		\begin{tabular}{llll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{2}{c}{\bf Inputs}\\
		& \bf \texttt{e} & \bf \texttt{min} \\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_min_0} & r1, r2, r3, r4, r5 & -1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_min_1} & r1, r2, r3, r4, r5 & 0\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_min_2} & r1, r2, r3, r4, r5 & n/2\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_min_3} & r1, r2, r3, r4, r5 & n-1\\
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{GetXsec_e_min_4} & r1, r2, r3, r4, r5 & n\\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double Get15percentBorder()}
	\subsubsection{Test Description}
	 Returns the integral from each data point to the last data point and returns the first one within 
15\% of the last data point.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{Get15percentBorder}}\label{Get15percentBorder_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{N/A}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Get15percentBorder_0} & N/A \\
		\bottomrule
		\end{tabular}
		\end{table}

\subsection{G4double Get50percentBorder()}% Test Cases Done
	\subsubsection{Test Description}
	 Returns the integral from each data point to the last data point and returns the first one within 
50\% of the last data point.
	
	\subsubsection{Test Inputs}
		\begin{table}[H]
		\centering
		\caption{Unit Tests - \texttt{Get50percentBorder}}\label{Get50percentBorder_unit}
		\begin{tabular}{lll}
		\toprule
		\multirow{2}{*}{\bf Test \#}  & \multicolumn{1}{c}{\bf Inputs}\\
		& \bf \texttt{N/A}\\\midrule
		\refstepcounter{TestCounter}\arabic{TestCounter}\label{Get50percentBorder_0} & N/A \\
		\bottomrule
		\end{tabular}
		\end{table}

%\begin{center}
%\begin{longtable}{p{0.15in}>{\raggedright\arraybackslash}p{1in}>{\raggedright\arraybackslash}p{0.6in}>{\raggedright\arraybackslash}p{1.5in}>{\raggedright\arraybackslash}p{2in}}
%\caption{Unit Testing -- \emph{G4NeutronHPVector.hh::Times(G4double factor)}}\label{Table_UnitTestsTimes}\\\toprule
%
%\bf \# & \bf Initial State & \bf Inputs & \bf Outputs & \bf Description\\\midrule
%\stepcounter{TestCounter}\arabic{TestCounter}
%& object represents vector (1,2,...,512) 
%& factor: 0 
%& no output, vector object now represents vector (0,0,...,0) of length 512 
%& multiplying non-zero vector object by 0 should change the object's state to a zero-vector of the same length\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents vector (1,2,...,512) 
%& factor: -1 
%& no output, vector object now represents vector (-1,-2,...,-512)
%& multiplying non-zero vector object by -1 should change the sign of all elements\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents vector (1,2,...,512) 
%& factor: 1 
%& no output, vector object still represents vector (1,2,...,512)
%& multiplying non-zero vector object by 1 should not change the object's state\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents vector (1,2,...,512) 
%& factor: 4 
%& no output, vector object still represents vector (4,8,...,2048)
%& multiplying non-zero vector object by 4 should multiply each element by 4\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents vector (0,0,...,0) 
%& factor: 0 
%& no output, vector object still represents vector (0,0,...,0)
%& multiplying zero vector object by 0 should not change the object's state\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents vector (0,0,...,0) 
%& factor: -1 
%& no output, vector object still represents vector (0,0,...,0)
%& multiplying zero vector object by -1 should not change the object's state\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents vector (0,0,...,0) 
%& factor: 1 
%& no output, vector object still represents vector (0,0,...,0)
%& multiplying zero vector object by 1 should not change the object's state\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents vector (0,0,...,0) 
%& factor: 4 
%& no output, vector object still represents vector (0,0,...,0)
%& multiplying zero vector object by 4 should not change the object's state\\
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& object represents empty vector
%& factor: 4 
%& exception raised 
%& multiplying an empty vector is an exception\\
%
%
%\bottomrule
%\end{longtable}
%\end{center}
%
%
%\begin{center}
%\begin{longtable}{p{0.15in}>{\raggedright\arraybackslash}p{1in}>{\raggedright\arraybackslash}p{1.1in}>{\raggedright\arraybackslash}p{1.5in}>{\raggedright\arraybackslash}p{1.5in}}
%\caption{Unit Testing -- \emph{G4NeutronHPVector.cc:: G4NeutronHPVector\& operator + (G4NeutronHPVector *left, G4NeutronHPVector *right)}}\label{Table_UnitTestsPlus}\\
%
%\toprule
%\bf \# & \bf Initial State & \bf Inputs & \bf Outputs & \bf Description\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& NA (vectors passed as arguments)
%& left: (1,2,...,512), right: (2,4,6,...,1048)
%& vector object representing (3,6,...,1560) 
%& adding two non-zero vectors should output the correct vector\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& NA (vectors passed as arguments)
%& left: (2,4,6,...,1048), right: (1,2,...,512)
%& vector object representing (3,6,...,1560) 
%& adding two non-zero vectors should output the correct vector\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& NA (vectors passed as arguments)
%& left: (1,2,...,512), right: (0,0,0,...,0) of length 512
%& vector object representing (1,2,...,512) 
%& adding a zero-vector to a non-zero vector should output the non-zero vector\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& NA (vectors passed as arguments)
%& left: (0,0,...,0) of length 512, right: (1,2,...,512)
%& vector object representing (1,2,...,512) 
%& adding a zero-vector to a non-zero vector should output the non-zero vector\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& NA (vectors passed as arguments)
%& left: (-1,-2,...,-512), right: (1,2,...,512)
%& vector object representing (0,0,...,0) of length 512 
%& adding a vector to its inverse should output the zero vector\\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& NA (vectors passed as arguments)
%& left: (1,2,3), right: (1,2,...,512)
%& vector object representing (2,4,6,...,512) of length 512 
%& adding a vector to a smaller vector outputs the larger vector with the addition applied to what elements it can \\\midrule
%
%\stepcounter{TestCounter}\arabic{TestCounter} 
%& NA (vectors passed as arguments)
%& left: (-1,-2,...,-512), right: empty vector
%& (-1,-2,...-512)
%& new vector will be the same at the left vector in this case \\
%
%\bottomrule
%\end{longtable}
%\end{center}
%

%The unit tests as described in tables \ref{Table_UnitTestsTimes} and \ref{Table_UnitTestsPlus} are not complete -- as the project progresses the number of tests will increase. Since functions are being ported one-at-a-time to the GPU, having full (or near-full) coverage is relatively straightforward. To accomplish this, every ported function must have a series of associated unit tests that cover a variety of edge and normal cases. Combined with system tests to test how all the parts work together, test coverage will be exhaustive.

% ----------------------------- Sub Section ----------------------------- %
\subsection{Code Testing} % Victor
The developers will follow strict code testing guidelines to help reduce coding errors and improve collaboration. This will be done by adhering to the \emph{Feature Branch Workflow} and enforcing code reviews for every commit. Developers will create separate branches for each new feature, commit to that branch and then push it to the repository. Using GitHub's pull request feature, all branches will go through a code review process. The author will open a pull request for their feature, and a different developer (to be chosen based on availability
\ds{``availability"}\mmp{fixed spelling mistake}
and knowledge of the feature) will be assigned as reviewer. The reviewer will manually read through the changes on GitHub and post comments as necessary. After comments have been addressed, the reviewer will merge the feature branch into the master. Following such a strict model will ensure that all committed code is double-checked by a different developer, which can catch many bugs and errors. This practice will not apply to changes to documentation.

% ----------------------------- Sub Section ----------------------------- %
\subsection{Requirements Testing} % Stuart
Testing requirements refers to tests which verify that documented requirements are met. The requirements documentation includes a variety of non-functional and functional requirements to be tested. The unit and system tests that will be run frequently will be aimed at testing the functional requirements related to the correctness of the system, as well as the non-functional requirements related to performance. At the end of development of Revision 0, other requirements will be tested. The results from those evaluations will lead to decisions made for the final product. The following table outlines Requirements Tests to be performed at the end of Revision 0 (not including those covered by unit  and system tests. Requirement number refers to that of the System Requirements Specification.

\begin{table}[!h]
\centering
\caption{Requirements Testing -- Tests for Revision 0}\label{Table_RequirementsTests}
\begin{tabular}{p{0.3in}>{\raggedright\arraybackslash}p{0.3in}>{\raggedright\arraybackslash}p{0.5in}>{\raggedright\arraybackslash}p{0.6in}>{\raggedright\arraybackslash}p{3.5in}}
\toprule
\bf Test \# & \bf Req. \# & \bf Inputs & \bf Outputs & \bf Description\\\midrule

\stepcounter{TestCounter}\arabic{TestCounter} 
& 2
& NA
& NA
& enabling GPU computations should be straightforward -- an extra flag for the CMake tool will be used to enable or disable it\\\midrule

%\stepcounter{TestCounter}\arabic{TestCounter} 
%& 4
%& NA
%& NA
%& trying to enable GPU computations on a computer with incompatible hardware should result in an appropriate error message\\\midrule

\stepcounter{TestCounter}\arabic{TestCounter} 
& 12
& NA
& NA
& software should be at least as stable as existing product -- running the new product with input files known to work on the existing product should not cause unexpected behaviour (i.e. crashing)\\\midrule

\stepcounter{TestCounter}\arabic{TestCounter} 
& 16
& NA
& NA
& clear installation instructions shall be included with the product -- a user comfortable with G4-STORK should be able to follow the instructions to install the product without any issues\\

\bottomrule
\end{tabular}
\end{table}
\mmp{removed hardware detection, no longer a requirement}

% ----------------------------- Sub Section ----------------------------- %
\subsection{Performance Profiling}
Performance results (i.e. how much improvement there is) will be measured through the system testing, however performance profiling during development will use proprietary CUDA profiling tools, as well as more general profiling software. 

\subsubsection{General Profiling}
Initially during development, the ``Time Profiling'' tool of the ``Instruments'' software package will be used to identify the most time consuming operations of the G4-STORK codebase. Identifying these operations first will allow the developers to easily pinpoint the areas that would best benefit from being ported to the GPU. As more functions are ported, the developers will continue to use ``Time Profiling'' to identify bottlenecks.

\subsubsection{CUDA Profiling}
NVIDIA has developed a solution for profiling CUDA code, called the ``NVIDIA Visual Profiler''. This tool will be used extensively to identify the areas of the CUDA code that can be improved, and to better understand how the software is using the hardware. This profiler is available as a plugin for the Eclipse IDE, and very thoroughly analyzes CUDA code for improvements.

% =============================== Section =============================== %
\section{Testing Factors}

% ----------------------------- Sub Section ----------------------------- %
\subsection{Factors to be Tested} % Rob
The purpose
\ds{``purpose"}\mmp{fixed spelling mistake}
of this section is to shed light on the features and properties of the system that we wish to stress and test. The chart below provides a brief description of every property we aim to measure and a method as means for measuring.\\

\begin{table}[h]
\centering
\caption{Test Factors}\label{Table_TestFactors}
\begin{tabular}{>{\raggedright\arraybackslash}p{0.2\textwidth}>{\raggedright\arraybackslash}p{0.4\textwidth}>{\raggedright\arraybackslash}p{0.3\textwidth}}
\toprule

\bf Factors & \bf Description & \bf Test Method\\\midrule
Correctness & Objective success or failure of a function & Unit Testing\\\midrule
Performance & Quantitative and Qualitative measure of temporal performance and stability in a particular workload & Unit Testing, black-box, System stress testing
\ds{How are you stress-testing the system?} \mmp{defined what type of stress testing will be used}
\\\midrule
Reliability & Consistent performance of functions in routine circumstances & Unit Testing, requirements\\\midrule

\bottomrule
\end{tabular}
\end{table}

% ----------------------------- Sub Section ----------------------------- %
\subsection{Description of Factor} % Matt
\subsubsection{Correctness}
Tests run on the GPU-enabled product should provide the same output as tests run on the existing product.\\

\textbf{Rationale}\\
In order for the product to be of use it must be able to compute the correct outputs.\\

\textbf{Methods of testing}
\begin{itemize}
\item The output files of tests run on the product will be compared with the output files of tests run on the non-GPU existing product
\item See risk \ref{R_RandNums} for more information on how they will be compared
\end{itemize}

\subsubsection{Performance}
Tests run with the GPU functionality enabled should take less time to compute compared to the same tests run on the the existing CPU-based product.\\

\textbf{Rationale}\\
The focus of this project is to reduce the computation time for G4-STORK by parallelizing functions on a GPU.\\

\textbf{Methods of testing}
\begin{itemize}
\item Compare the computation times of tests run on the product with GPU enabled with the computation times of test run on the existing product to see if the GPU-based computation times are smaller.
\end{itemize}

\subsubsection{Reliability}
Consistent performance of functions in routine circumstances.\\

\textbf{Rationale}\\
Research software requires functions to perform reliably in order to produce results that can be duplicated.\\

\textbf{Methods of testing}
\begin{itemize}
\item Running the same test multiple times should produce the same result every time.
\end{itemize} 
% =============================== Section =============================== %
\section{Manual and Automated Testing}
Manual testing needs to be conducted by people, where test cases and inspections are manually performed. On the other hand, automated testing relies less on people and performs tests quickly and effectively returning feedback on results not meeting expectations. Manual testing is more flexible; However, it is far more time consuming.\\

Our system testing will be done automatically -- a small script will be written to run the example and check the output file against an output file from the existing product. Unit tests will also be automated, by passing in specific inputs to modified functions and checking that output against the correct output from the existing product.

\subsection{Automated System Testing}
A small script will be created to run the chosen example file and compare the output file with the correct output file from the existing product. If the results are the same within a margin of error elicited from consultation with the stakeholders, then the test is passed. Although the test itself will be automated, it will be manually run by the developers. This will let the developers try out different example files at different times, and to choose more complex ones when larger changes are made. The output files contain run-time data which will be used to evaluate performance.

\subsection{Automated Unit Testing}
A testing class will be added to the project which will contain all unit tests. These will be created as functions are ported to the GPU by deciding on several inputs and recording the results as well as the running time from the existing CPU-bound product. The testing class will then call the ported function with the same inputs and verify that the outputs are the same. The testing function will record performance while it runs to ensure that the changes are positive from a performance standpoint. If the results for all functions in the testing class match the expected results, the unit tests have passed. The unit tests will be manually run throughout development as the developer sees fit. As well as those frequent tests, all unit tests must pass before any code is merged into the repository. Changes that cause a performance regression will be allowed, under the assumption that they will be improved upon until their performance is better than the existing non-GPU functions.

% =============================== Section =============================== %
\section{Proof of Concept Test}
As documented in the Proof of Concept Plan, the demonstration will include running GEANT4 examples with and without GPU computation enabled, as well as a very minor CUDA example. Since it is not planned to have any ported functions running on the GPU, unit tests will not be used at this point. A full system test will be used to verify that adding the small CUDA example does not impact the results. It is expected that the CUDA example won't affect the results, as it will not be passing any data back to G4-STORK to be used. The empty unit testing file (along with a trivial unit test) will be included in the project, and may be demonstrated if requested.

% =============================== Section =============================== %
\section{Schedule}
The testing schedule can be summarized as follows: manual code reviews for every commit, unit tests added for every ported function and run throughout development and passed before every commit, system tests run throughout development and passed before every commit, performance profiling used throughout development, requirements testing done for Revision 0. The following testing timeline will be followed. The \emph{date} column refers to the date by which the event shall be completed, if it is not a range.

\begin{center}
\begin{longtable}{>{\raggedright\arraybackslash}p{0.1\textwidth}>{\raggedright\arraybackslash}p{0.15\textwidth}>{\raggedright\arraybackslash}p{0.55\textwidth}
>{\raggedright\arraybackslash}p{0.1\textwidth}
}

\caption{Testing Schedule}\label{Table_Schedule}\\\toprule

\bf Date & \bf Test Type & \bf Event & \bf Testers\\\toprule
2015-11-04 & System Test & Input files will be chosen for system tests, and their outputs on the existing product recorded & Everyone \\\midrule
2015-11-04 & System Test & Script will be created to run system test and compare results. Running the script on the existing product will pass \& Victor and Rob\\\midrule
2015-11-04 - 2016-04-01 & System Test & System tests will be run throughout development, and must be passed before every commit & Matt \& Stuart\\\midrule
2015-11-04 - 2016-04-01 & Code Testing & All changes will be reviewed by a different developer before merging & Matt\\\midrule
2015-11-06 & Performance Profiling & Profiling tools will be used to identify the most computationally involved portions of the codebase & Rob \& Victor\\\midrule
2015-11-10 & Unit Test & Unit tests framework file will be created and added to the project. Methods will be added to run tests and report their results.& Victor \\\midrule
2016-11-10 & Unit Test & Two trivial unit tests (one that will fail, one that will pass) will be added to unit tests file. Running the unit tests should produce expected outputs. Rob \& Victor\\\midrule
2015-11-10 - 2016-04-01 & Unit Test & Unit tests will be added throughout development for every function that is ported to the GPU. & Matt\\\midrule
2015-11-10 - 2016-04-01 & Unit Test & Unit tests will be run throughout development, and must be passed before every commit & Matt\\\midrule
2016-02-10 & Requirements Testing & All requirements tests will be evaluated at Revision 0, results will guide product development for Revision 1. & Everyone\\

\bottomrule
\end{longtable}
\end{center}

\ds{Who will be doing what?}\mmp{Added people to work on specific testing tasks}

% ----------------------------- Sub Section ----------------------------- %
\subsection{Deliverables} % Rob
The deliverables specific to testing are as follows:

\begin{center}
\begin{longtable}{>{\raggedright\arraybackslash}p{0.2\textwidth}>{\raggedright\arraybackslash}p{0.25\textwidth}>{\raggedright\arraybackslash}p{0.45\textwidth}}
\caption{Timeline of Deriverables}\label{Table_Deliverables}\\\toprule

\bf Date & \bf Deliverable & \bf Description\\\toprule
2015-10-30 & Test Plan Revision 0 & set guidelines and objectives for testing, subject to change\\\midrule
2016-03-21 & Test Report Revision 0 & report on progress, history, and results regarding testing and test methods\\\midrule
2016-04-01 & Test Plan Final & rigorously outline test cases and considerations in preparation
\ds{``preparation"}\mmp{fixed}
for the projects final release\\\midrule
2016-04-01 & Test Report Final & report on the final results of tests performed and provide relevant analytics\\\bottomrule

\end{longtable}
\end{center}

\ds{Will you be doing any tests that result in exceptions? How will those be performed?
 You are missing a lot of edge/boundary test cases (or you do not make it clear that
 they are being tested).}
\mmp{Added a few exception and edge case tests in unit testing and system testing}

\end{document}