Check out C++ standard:  rules for compatibility of void * with other pointers.

--TOPC-verbose with --mpi:
  TOPC_init() -- printout mixed w/ app printout.  Fix it?
  ALSO:  "... `hostname` connected."  messages coming in late.
  MAYBE ADD:  Connecting to `hostname` ... (so it displays earlier??)

Note:  no security in MPINU, open to man-in-the-middle attacks.
If this is a problem for you, do _not_ use MPINU.  Use a different
implementation of MPI.

ADD doc/topc.texi:
  Using an MPI other than the built-in TOP-C libmpinu
SEE:  ~/projects/topc-2/topc.texi-extra
dnl topc-config.in:  --mpi)
dnl  Note that with_mpi_cc != no means libmpi="".
dnl  This is the right thing if using ${MPICC}
dnl  Maybe we should have undocumented --mpi-internal returning this,
dnl    which is called from topcc.in and topc++.in,
dnl    while --mpi  should indicate problem and:  exit 1
dnl # Do all of this for MPICXX also

Compare with:  ~/projects/topc-2/SSH-SETUP about using without passwords.

Create DEBIAN file.

Should we use in mpinu?
execvp is nicer and is POSIX.1:
:   if (-1 == execvp("mpirun %s...", argv...)) {
            perror("execvp"); exit(1);
         }
Probably ought to revisit mpinu with these issues.
Finish setting up use of alternative MPI w/ C++ (to be done as with C)

One page summary of all TOP-C commands, mirroring Appendix (chapter org.)

Don't call malloc() or free() for messages of size <= 2 * sizeof_msg_hdr
Instead, keep free list (w/ mem_hdr_free_head) of buffers of that size:
memory.c:
//=============================================================
// push/pop onto free list:  better cache performance than FIFO
struct short_msg {
  ... struct msg_hdr fields ...
  data;
}
static struct short_msg initial_free_list[NUM_INITIAL_FREE_LIST],
                        *free_list = NULL;
static int initial_free_list_used = 0;
static struct short_msg *pop_free_list() {
  struct short_msg *tmp;
  if (free_list == NULL) {
    if (! initial_free_list_used) {
      struct short_msg *tail = initial_free_list+NUM_INITIAL_FREE_LIST-1;
      free_list = initial_free_list;
      for (tmp = free_list; tmp < tail; tmp++)
        tmp->next = tmp + 1;
      initial_free_list_used = 1;
    } else {
      free_list = malloc(sizeof(struct short_msg));
      free_list->next = NULL;
    }
  }
  tmp = free_list;
  free_list = free_list->next;
  return tmp;
}
static void push_free_list(struct short_msg *tmp) {
  tmp->next = free_list;
  free_list = tmp;
}
//=============================================================
and initialize next and prev pointers of following buffer and update
mem_uninit_msg upon doing so.

Add TOPC_task_tmp_data() or else app-declared destructor callback function
so that TOP-C can free/delete buffer no longer used.
Note:  C++ has two destructors, free/delete, and application
  may want to declare third.
DISCUSS further best interface.
TOPC_task_tmp_data(void *)
void *TOPC_task_tmp_data(void *) would cause TOP-C to free the argument
  at the end of a task.  Common usage:
TOPC_MSG(TOPC_task_tmp_data(data),size);
On the master, this means to free(data) after GenerateTaskInput() is done.
On the slave, this means to free(data) after there are no more
  REDO's or CONTINUATION()'s for this task (i.e.:  when we see new task).
Initially, could insist that this be called at most once per
  task, although that restriction could be lifted later.
TOPC_task_tmp_data(void *) will be especially important in
  conjunction with TOPC_MSG_PTR() and aggregation, since there
  may be several send messages pending in queue.

src/comm-mpi.c:msg_info code can probably just use code from src/memory.c

Can we test for memory overcommit by application?
(We sort of do it now by trial malloc when TOPC_init() gains control.
It affects example/simple.c

comm-mpi.c:  Better name for cache_thread, cache_thread_msg, etc.
       (receive thread, receive buffer)
Explain in manual, when debugging with gdb, turn off receive thread
  for easier debugging.

Create a reference sheet for TOP-C commands (maybe two pages per side).
       Base it partly on Summary section of manual.

MANUAL:  Add the comments at the beginning of the manual into
        the manual.

Absorb some of .future/doc/manual.dvi and .future/doc/topc.tex
        into topc.texi and into a future topc-tutorial.texi

Consider providing guarantee that TOP-C never calls malloc() if
TOPC_MSG_PTR() is used instead of TOPC_MSG().

> TOPC_malloc_tmp() probably is not worth the extra complication, but
> it can be considered.
TOP_malloc_tmp(size) -- Equivalent of malloc(), except that the buffer
        would be freed at the end of a task (After REDO's and
        CONTINUATION).  What would be the equivalent for C++?
        Also add --TOPC_safety level that plays tricks with mmap
        to detect if the user has tried to access a buffer that was freed.

sendahead messages -- GenerateTaskInput() is called n times for each slave,
        even while that slave is busy.  This maintains a queue of n
        tasks for the slave that can be sent and stored on the
        slave processor even while the slave is finishing its current
        task.  Even for n = 1, this can be significant, since it
        provides overlapped communication and computation.  On the
        downside, it means that the application generates the next
        task for a slave before seeing the result of a previous
        task, and the result may be that the new task generated
        is less useful.
            When this is implemented, the logic for the receive thread
        in comm-mpi.c could also be separated out, and joined
        with a new file for management of TOP-C buffers and queues.

marshalling -- add something, perhaps like MPI_Pack/Unpack, but with
        extra arg for field name/type for error checking.  Perhaps
        have TOPC_pack_first(char *name, buf, size),
        TOPC_pack_next(char *name, buf, size).

implement slave stats

Extend examples to simple examples of simulated annealing and neural nets?
simple work-stealing example for search (a la CILK)??

==========================================================================
MUCH FURTHER IN THE FUTURE:
Add pages for shared memory model (and so eliminate current ralse sharing,
  where all of shared data acts as a single large page).  As with the
  rest of the TOP-C philosophy, a page will not be declared to TOP-C,
  and so it will be more like a lock used by an application to lock
  access to a region of memory.  Such locks do not need to have
  the region of memory declared to them.
In distributed memory, add greater robustness for dead or slow slaves.
  Have backoff algorithm that re-allocates a slave task if a slave
  doesn't reply in a certain time.  If the new slave computes the task
  before the old slave can reply, declare the old slave to be dead
  and stop using it.  Do _not_ use socket of that
  dead slave unless a handler is in place, since that could crash the
  master process.  For now, I prefer to do without signal handlers,
  to avoid conflicts with the application signal handlers.
Revive previous experiment with ability to start new slaves dynamically
  during an ongoing TOP-C computation.
Add mixed distributed/shared memory model for clusters of
  multiprocessor computers.
  It becomes a tree with master node, communicating with distributed
  slaves, who then have shared memory slaves below them.
Add a general model for a tree of masters to handle cases
  when master might become overloaded.  (Although I haven't
  seen this case arise yet.)
Add support for large amounts of data in distributed memory model
  that don't fit all on one node.  This gets closer to the realm
  of DSM.
