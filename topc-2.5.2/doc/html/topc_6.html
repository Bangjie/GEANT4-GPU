<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<!-- Created on October, 6  2004 by texi2html 1.65 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>TOP-C (Task Oriented Parallel C/C++): Debugging and Tracing</TITLE>

<META NAME="description" CONTENT="TOP-C (Task Oriented Parallel C/C++): Debugging and Tracing">
<META NAME="keywords" CONTENT="TOP-C (Task Oriented Parallel C/C++): Debugging and Tracing">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.65">

</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC27"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_5.html#SEC26"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC28"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_5.html#SEC19"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 6. Debugging and Tracing </H1>
<!--docid::SEC27::-->
<P>

<A NAME="IDX84"></A>
<A NAME="IDX85"></A>
</P><P>

If the difficulty is that the application fails to start in the distributed
memory model (using <CODE>topcc --mpi</CODE>), then read
<A HREF="topc_5.html#SEC25">5.4.2 If Slaves Fail to Start</A>, for some
debugging techniques.  Note also that TOP-C ignores SIGPIPE.  This is
because TOP-C employs the SO_KEEPALIVE option, and the master process
would otherwise die if a slave process were to die.  SO_KEEPALIVE
is needed for robustness when slave processes execute long tasks without
communicating with the master process.
The rest of this section assumes that the
application starts up correctly.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="topc_6.html#SEC28">6.1 Debugging by Limiting the Parallelism</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="topc_6.html#SEC29">6.2 Debugging with `<SAMP>--TOPC-safety</SAMP>'</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="topc_6.html#SEC30">6.3 TOP-C and POSIX signals</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="topc_6.html#SEC31">6.4 Tracing Messages</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="topc_6.html#SEC32">6.5 Stepping Through a Slave Process with `<SAMP>gdb</SAMP>'</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="topc_6.html#SEC33">6.6 Segmentation faults and other memory problems</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Debugging by Limiting Parallelism"></A>
<HR SIZE="6">
<A NAME="SEC28"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC29"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.1 Debugging by Limiting the Parallelism </H2>
<!--docid::SEC28::-->
<P>

First, compile and link your code
using <CODE>topcc --seq --TOPC-safety=20 -g -O0</CODE>,
and make sure that your application works correctly sequentially.  Only after
you have confidence in the correctness of the sequential code, should you
begin to debug the parallel version.
</P><P>

If the application works correctly in sequential mode, one should debug
in the context of a single slave.  It is convenient to declare the
remote slave to be <CODE>localhost</CODE> in the `<TT>procgroup</TT>' file, in order
to minimize network delays and so as not to disturb users of
other machines.  In this case, the code is "almost"
sequential.  An easy way to do this is:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  topcc --mpi --TOPC-num-slaves=1 -g -O0
</pre></td></tr></table></P><P>

Next, one should test on two slaves, and finally all possible slaves.
</P><P>

<A NAME="Debugging with --TOPC-safety"></A>
<HR SIZE="6">
<A NAME="SEC29"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC28"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC30"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.2 Debugging with `<SAMP>--TOPC-safety</SAMP>' </H2>
<!--docid::SEC29::-->
<P>

<A NAME="IDX86"></A>
<A NAME="IDX87"></A>
</P><P>

The command-line option `<SAMP>--TOPC-safety=<VAR>val</VAR></SAMP>' provides assistance
for debugging parallel programs.  At higher values of <VAR>val</VAR>,
optimizations that do not change the correctness of the program are
converted to safer equivalents.  A good strategy is to
test if `<SAMP>--TOPC-safety=20</SAMP>' causes the bug to go away, and if so,
progressively lower <VAR>val</VAR> toward zero, until the bug reappears.
The value at which the bug reappears indicates what `<SAMP>TOP-C</SAMP>'
optimization feature is not being used correctly.  If the bug still
exists at `<SAMP>--TOPC-safety=20</SAMP>', one should next try compiling
with the `<SAMP>--seq</SAMP>' flag and use a debugger to debug the sequential code.
</P><P>

The effects due to different safety levels are subject to change.
To see the current effects, invoke any TOP-C application as follows
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  ./a.out --TOPC-help --TOPC-verbose
</pre></td></tr></table>and you will see something like:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  safety: &#62;=0: all; &#62;=2: no TOP-C memory mgr (uses malloc/free);
  &#62;=4: no TOPC_MSG_PTR; &#62;=8: no aggreg.;
  &#62;=12: no TOPC_abort_tasks; &#62;=14: no receive thread on slave;
  &#62;=16: default atomic read/write for DoTask, UpdateSharedData;
   =19: only 2 slaves; &#62;=20: only 1 slave
  (AGGREGATION NOT YET IMPLEMENTED)
</pre></td></tr></table></P><P>

Values higher than 4 cause <CODE>TOPC_MSG_PTR()</CODE> to act as
if <CODE>TOPC_MSG()</CODE> was called instead.
Values higher than 12 cause <CODE>TOPC_abort_tasks()</CODE> to have no effect.
Values higher than 14 imply that a single thread in the slave process
must receive messages and execute <CODE>DoTask()</CODE>.  Normally,
`<SAMP>TOP-C</SAMP>' arranges to overlap communication and computation on the
slave by setting up a separate thread to receive and store messages from
the master.
Values higher than 15 imply that `<SAMP>TOP-C</SAMP>' will use malloc instead
of trying to do its
own memory allocation (which is optimized for `<SAMP>TOP-C</SAMP>' memory
patterns).
Values higher than 16 imply that all of <CODE>DoTask</CODE> acts as
if a read lock was placed around it, and all of <CODE>UpdateSharedData</CODE>
has a write lock placed aound it.  (This has an effect only
in the shared memory model where calls to <CODE>TOPC_ATOMIC_READ/WRITE</CODE>
are ignored.)
At values of 19 and 20, the number of slaves is reduced to
2 and to 1, regardless of the setting of `<SAMP>--TOPC-num-slaves</SAMP>'
and the specification in a `<TT>procgroup</TT>' file.
</P><P>

<A NAME="TOP-C and POSIX signals"></A>
<HR SIZE="6">
<A NAME="SEC30"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC29"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC31"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.3 TOP-C and POSIX signals </H2>
<!--docid::SEC30::-->
<P>

If an application handles its own signals, this can create a clash
with the TOP-C.
In the distributed memory model (--mpi), `<SAMP>TOP-C</SAMP>' will create its own
signal handlers for <CODE>SIGALRM</CODE>.  This is used in conjunction with
<CODE>alarm()</CODE> to eventually kill runaway
slave processes.  In addition, if using `<SAMP>MPINU</SAMP>',
the built-in MPI subset, `<SAMP>TOP-C</SAMP>' will create its own handler
for <CODE>SIGPIPE</CODE>.  This is in order to allow the master
process to detect dead sockets, indicating dead slaves.
Finally, for short periods, `<SAMP>MPINU</SAMP>'
will disable the use of <CODE>SIGINT</CODE> around calls to <CODE>select()</CODE>.
Nevertheless, if a SIGINT is sent during this period, TOP-C will pass the
signal on to the original SIGINT handler of the application.
</P><P>

`<SAMP>TOP-C</SAMP>' does not modify signal handlers in the sequential (--seq)
or shared memory (--pthread) models.  Furthermore, if a different
MPI (other than MPINU) is used with TOP-C, TOP-C will only handle
<CODE>SIGALRM</CODE>.  However, the other MPI may handle signals itself.
See section <A HREF="topc_13.html#SEC61">C. Using a Different `<SAMP>MPI</SAMP>' with TOP-C</A>.
</P><P>

<A NAME="Tracing Messages"></A>
<HR SIZE="6">
<A NAME="SEC31"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC30"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC32"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.4 Tracing Messages </H2>
<!--docid::SEC31::-->
<P>

<A NAME="IDX88"></A>
<A NAME="IDX89"></A>
<A NAME="IDX90"></A>
</P><P>

If a bug appears as one moves to greater parallelism, one should trace
messages between master and slaves (for any number of slaves).
This is the default, and it can be enabled on the command line with:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  ./a.out --TOPC-trace=2 <VAR>args</VAR>
</pre></td></tr></table>The variable <CODE>TOPC_OPT_trace</CODE> can be set in the code to
dynamically turn tracing on (1 or 2) and off (0) during a single run.
A trace value of 2 causes `<SAMP>TOP-C</SAMP>' to invoke the application-defined
trace functions pointed to by
<CODE>TOPC_OPT_trace_input/result</CODE>.  If the application has not
defined trace functions, or if <CODE>TOPC_OPT_trace</CODE> is 1, then
the `<SAMP>TOP-C</SAMP>' default trace functions are invoked.
All message traces
are displayed by the master at the time that the master sends or
receives the corresponding message.
</P><P>

<A NAME="IDX91"></A>
<DL>
<DT><U>Variable:</U> void (*)(void *input) <B>TOPC_OPT_trace_input</B>
<DD><A NAME="IDX92"></A>
<DT><U>Variable:</U> void (*)(void *input, void *output) <B>TOPC_OPT_trace_result</B>
<DD>         Global pointer (default is <CODE>NULL</CODE>) to function returning
         <CODE>void</CODE>.  User can
         set it to his or her own trace function to print out
         data-specific tracing information in addition to generic
         message tracing of <CODE>TOPC_trace</CODE>.
</DL>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>EXAMPLE:  if you pass integers via <CODE>TOPC_MSG()</CODE>, define
  <CODE>TOPC_trace_input()</CODE> as:
         void mytrace_input( int *input ) {
           printf("%d",*input);
         }
         TOPC_OPT_trace_input = mytrace_input;
</pre></td></tr></table></P><P>

Note that the term `<SAMP>result</SAMP>' in <CODE>TOPC_OPT_trace_result</CODE>
refers to an `<SAMP>(input, output)</SAMP>' pair.
</P><P>

<A NAME="Stepping Through a Slave"></A>
<HR SIZE="6">
<A NAME="SEC32"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC33"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.5 Stepping Through a Slave Process with `<SAMP>gdb</SAMP>' </H2>
<!--docid::SEC32::-->
<P>

<A NAME="IDX93"></A>
</P><P>

If you find the master hanging, waiting for a slave message, then the
probable cause is that <CODE>DoTask()</CODE> is doing something bad (hanging,
infinite loop, bus/segmentation error, etc.).  First try to isolate the
bug using a symbolic debugger (e.g. `<SAMP>gdb</SAMP>') and the sequential memory
model.  If your intended application is the shared memory model, you can also
use `<SAMP>gdb</SAMP>' to set a breakpoint in your `<SAMP>DoTask</SAMP>' routine
or at the `<SAMP>TOP-C</SAMP>' invocation, <CODE>do_task_wrapper</CODE>.
</P><P>

If the bug only appears in the distributed memory model, you can still
symbolically debug <CODE>DoTask()</CODE> using `<SAMP>gdb</SAMP>' (the GNU C debugger)
and its <CODE>attach</CODE> command
(see section `Attach' in <CITE>The GNU debugger</CITE>),
which allows you to attach and debug a separate running process.  This
lets you debug a running slave, if it is running o the same processor.
For this strategy, you will want the slave to delay executing to give
you time to execute gdb and attach on the remote host or remote thread.
The command line option `<SAMP>--TOPC-slave-wait=30</SAMP>' will force
the slave to wait 30 seconds before processing.
</P><P>

In applying this debugging strategy to an application `<SAMP>./a.out</SAMP>',
one might see:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  [ Execute ./a.out in one window for master process ]
  gdb ./a.out
  (gdb) run --TOPC-trace=1 --TOPC-safety=19 --TOPC-slave-wait=30 <VAR>args</VAR>

  [ In a second window for a slave process on a different host, now type: ]
  ps
    ...
    1492  p4 S    0:00 a.out <VAR>args</VAR> localhost 6262 -p4amslave
  gdb a.out
  ...
  (gdb) break do_task_wrapper
    Breakpoint 1 at 0x80492ab: file ...
    [ `break slave_loop' is also useful.  This calls do_task_wrapper ]
  (gdb) attach 1492
    Attaching to program `a.out', process 1492
    0x40075d88 in sigsuspend ()
  [ After 30 sec's, traced messages in master window appear, ]
  [ for slave, type: ]
  (gdb) continue
    Continuing.
    Breakpoint 1, DoTask (input=0x805dc50) at ...

  [ Continue stepping through master and slave processes in 2 windows ]
</pre></td></tr></table></P><P>

If you try to <EM>attach</EM> to a second slave process after attaching
to a first slave process, `<SAMP>gdb</SAMP>' will offer to kill your first
slave process.  To avoid this situation, remember to execute <CODE>detach</CODE>
before attaching a second slave process.
</P><P>

<A NAME="Segmentation faults"></A>
<HR SIZE="6">
<A NAME="SEC33"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC32"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 6.6 Segmentation faults and other memory problems </H2>
<!--docid::SEC33::-->
<P>

<A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
</P><P>

Memory bugs are among the most difficult to debug.
If you suspect such a bug (perhaps because you are using <CODE>TOPC_MSG_PTR</CODE>),
and you fail to free previously malloc'ed memory, that is a memory leak.
If you access a buffer after freeing it, this may cause
a segmentation error at a later stage in the program.
</P><P>

If you suspect such a bug (and maybe you should if nothing else
worked), it is helpful to use a <EM>malloc or memory debugger</EM>.
An excellent recent memory debugger is
`<SAMP>valgrind</SAMP>'<A NAME="DOCF2" HREF="topc_fot.html#FOOT2">(2)</A>.
`<SAMP>valgrind</SAMP>' can be directly applied to an application binary,
without recompilation or relinking.
</P><P>

An older debugger is `<SAMP>efence</SAMP>',<A NAME="DOCF3" HREF="topc_fot.html#FOOT3">(3)</A>
<CODE>topcc</CODE>
provides direct support for `<SAMP>efence</SAMP>'.
`<SAMP>TOP-C</SAMP>' will link with the efence library if <CODE>--efence</CODE>
is passed to <CODE>topcc</CODE> or <CODE>topc++</CODE>.
<TABLE><tr><td>&nbsp;</td><td class=example><pre>  topcc --efence ...
</pre></td></tr></table>This causes all calls to <CODE>malloc</CODE> and <CODE>free</CODE> to
be intercepted by the `<SAMP>efence</SAMP>' version.
Modify the line <CODE>LIBMALLOC=</CODE> in <CODE>topcc</CODE> or <CODE>topc++</CODE>
if you use a different library.
</P><P>

<A NAME="Performance and Long Jobs"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_6.html#SEC27"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_7.html#SEC34"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_14.html#SEC62">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="topc_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gene Cooperman</I> on <I>October, 6  2004</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
