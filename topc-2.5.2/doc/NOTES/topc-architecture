topc.c contains the main algorithm.
  topc.c, options.c, memory.c and procgroup.c form a layer on top of
  the `comm' layer:
    options.c introduces the global, non-static symbols TOPC_OPT_*
    					and the constants SAFETY_*
					in comm.h and topc.h
    memory.c exports MEM_malloc, MEM_register_buf, MEM_free,
    		     TOPC_MSG, TOPC_MSG_PTR
  The comm layer includes:  comm-mpi.c, comm-pthread.c and comm-seq.c
     The interface to the comm layer is through symbols:  COMM_*
       that are declared in comm.h
  The comm-mpi.c module sits on top of MPINU (an MPI layer).

MAIN PROCEDURES:
  The primary routines are:
    TOPC_master_slave:  contains `heart' of the algorithm
  TOPC_raw_submit_task_input (especially)
    and TOPC_raw_begin_master_slave, TOPC_raw_end_master_slave
    together have the equivalent functionality of TOPC_master_slave
  Some global variables are:
    num_slaves
    num_idle_slave (# for which slave[i].busy == FALSE)
    num_dead_slaves (# for which slave[i].dead == TRUE)

  TOPC_master_slave calls:
    wait_until_an_idle_slave
    COMM_generate_task_input
    MEM_registger_buf   (see memory module)
    submit_task_input   (if new input available)
    receive_task_output (if no new input available, blocks until output avail.)
  wait_until_an_idle_slave calls:
      If num_idle_slaves > 0, just return immediately.
    receive_task_output (if no slaves are idle, this will create an idle slave)
    new_dead_slave     (Now there is one idle slave; check if it is dead)
    submit_task_input  (if it was dead, resubmit its task to a new slave)
QUESTION:  suppose no new idle slave is available?
      If num_idle_save == 0 still, go back to receive_task_output
  submit_task_input calls:
      PRECONDITION:  num_idle_slaves > 0
    find_available_slave  (Precodition is that num_idle_slaves > 0)
    trace_input
    add_to_aggregate_buffer (If application using aggregated tasks)
    send_task_input
  send_task_input calls:
    update_slave
    COMM_send_msg
  receive_task_output calls:
    COMM_receive_msg
    trace_result
    COMM_free_receive_buf  (tell COMM layer to free the receive buffer that
    				it created in COMM_receive_msg)
    free_input_data (MEM_free)

initialization:

aggregated tasks:
    Code for aggregated tasks limited to:  if (TOPC_OPT_aggregated_tasks > 1)
      and it occurs only in src/topc.c .
    If next task input is NOTASK, send out pending task (don't wait).
    Note that if pending message too large, submit_task_input calls
      itself again with argument NOTASK as signal to send out.
    At beginning of TOPC_master_slave, on master, each slave_array element
      (for each slave) is given buffer
      for aggreg_inputs of default size AGGREG_TASKS_SIZE .
      The buffer is freed at end of TOPC_master_slave.
    For any "large message" (pending message whose size goes over
      AGGREG_TASKS_SIZE), we call realloc() to resize the buffer.
      The new size may be larger or smaller than previously.  The
      cost of realloc() will be small compared to sending a large message.
      "Small messages" don't require realloc.
    The pending message is always kept in the buffer of aggreg_tasks,
      which is static in submit_task_input.  When the buffer is sent
      out, the buffer of aggreg_tasks is exchanged with that of
      the slave_array element for the right slave.

updates:
    Updates must be broadcast to all slaves.  Since some slaves are
    typically busy, we implement an update_queue to hold pending updates.
    The primary procedures are:

    update_slave:


dead slaves:
    COMM_send_msg:
      Check for dead slave whenever COMM_send_msg.  If dead slave
      found, record dead and increment nm_dead_slaves
    broadcast_update:  broadcast to slave only if it's not dead
    find_available_slave:  satisfying ! slave[i].dead
    receive_task_output:  ignore output from dead slaves
    wait_until_an_idle_slave:
      If idle slave is dead, resubmit its input and try again for idle slave
QUESTION:  Suppose it's a CONTINUATION?  (input is not original input)
    master_slave_chdir:  Don't do it for dead slaves
    TOPC_master_slave:  We receive_task_output only if
    		num_idle_slaves + num_dead_slaves < num_slaves

memory:
    We want to check if an application calls TOPC_MSG() twice, since this
    can cause memory leaks.  An application calls TOPC_MSG(), which uses
    MEM_malloc to allocate new memory.  MEM_register_buf is called
    from within the heart of TOP-C, and it records that the MEM_malloc
    buffer was passed to TOP-C.  If also checks that there are no
    outstanding earlier MEM_malloc buffers that have not yet been registerd.
    Finally, MEM_free is used by the heart of TOP-C to free any
    MEM_malloc buffers that TOP-C no longer uses.  Since TOP-C's own
    TOPC_MSG had internally called MEM_malloc, the application code should
    have no pointers to this internal buffer that is freed by MEM_free.

    In fact, topc.c uses free_input_data to free any buffers on the master
    side.  This directly calls MEM_free.  On the slave side,
    MEM_free is called directly from inside slave_loop.

receive threads:



==============================================
memory module (MEM_*):
