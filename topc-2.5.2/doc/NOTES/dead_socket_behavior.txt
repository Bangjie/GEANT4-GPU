THESE ARE OLD DESIGN NOTES FOR HANDLING ISSUE OF DEAD SLAVES.
THE FIRST PART ABOUT THE UNIUX/Linux HANDLING OF DEAD SOCKECTS
  IS STILL PERTINENT.

document:

When a socket is dead, it will send a FIN to its partner.
An RST is TCP's response to some packets that it doesn't expect and has no other way of 
dealing with. A common case is when the peer closes the connection (sending you a FIN) 
but you ignore it because you're writing and not reading. So you write to a 
connection that has been closed by the other end and the other end's TCP responds 
with an RST.

The following is what we observed on Sun Solaris and isn't documented .
1. Reading a FIN, the read() call will  return 0 and no error is set.
The following read() calls will return 0 and no error is set.

2. Having not read the FIN and writing to a dead socket, it will recieve an RST from the partner.
The following write() call will generate a sigpipe signal, return -1 with error = EPIPE. 

3. The first read() call, on a socket that has recieved an RST,  will return -1 with error = ECONNRESET.
The following read() calls will return 0 and errno is not reset.

4. If there is a FIN received by the socket, the select() call will indicate 
that the socket is both readable and writable.

EPIPE(32):	
Broken pipe.  A write on a pipe or FIFO for which there is no process to read the data.

ECONNRESET(131): 
Connection reset by peer. A connection was forcibly closed by a peer.  
This normally results from a peer executing a shutdown(2) call.



logic of TOP-C when slaves dies
  comm-recv() : call MPI_Recv
  comm-send() : call MPI_Send

MPINU uses SO_KEEPALIVE. Therefore it ignores SIGPIPE signals. Otherwise, whenever SO_KEEPALIVE
 ceates a new probe on the socket, if the socket is dead, the TOPC process will die.
If socket dies, SO_KEEPALIVE continues to probe, causing
extra SIGPIPE's. But when we discover dead slave, we'll close socket.

in MPI:
slave[];
initialization: slave[i] = ALIVE;
if slave[i] == DEAD , meaning ith slave dead.



comm-recv(){

 tryagain:

 MPI_Probe(,, &status, ); //MPI_Probe calls select() and MPI_read_hdr()	 
 //In MPI_read_hdr, if read returns 0, we know the socket is dead and we should
 //clear this socket in the fd_set, so in the future we will not check this socket any more		
 //slave[i] = DEAD;
 MPI_Probe computes msg size and decides MPI_SOURCE according to status.


 MPI_Recv() is called by comm-recv() with msg size and source parameters filled in by MPI_Probe();


SUPPOSE: socket dies after MPI_Probe() call and before or during MPI_Recv() call returns, 
SOLUTION: delete the dead socket and call MPI_Probe() again, this is done transparently to TOP-C.

 if(MPI_FAIL == MPI_Recv(, status.MPI_SOURCE, size, , )
   goto tryAgain;
  //in MPI_Recv, if recv() call also returns 0 or -1 with ECONNRESET, 
  //we should clear the socket in the fd_set.
  //MPI_Recv return MPI_FAIL;
  //slave[i] = DEAD;
}



comm-send(){

 if(MPI_FAIL == MPI_Send())
 //If MPI_Send() returns fail, we ignore the failure and detect it later 
 //when task's ID is out of some scope.
 //Also we make some changes in MPI_Send(), if MPI_Send() finds out a socket is dead,
 //MPI_Send() will deletes that socket from the fd_set.	
 	
 //MPI_Send call send(), if send() call return -1 and errno = EPIPE, 
 //we should clear the socket in the fd_set
 //MPI_Send return MPI_FAIL; 
 //revise comm-send() return TOPC_BOOL and 
 //need to fix other comm-send() functions in other senarios, such as TOPC-seq
 //the logic of TOPC is:
 //ignore the return value of comm_send() 
 //consider every task is sent out and put it in task queue
 //using the task ID values as the time expire label
 //resend task if the ID indicates that task need to be resend
}

When a task times out in src/topc.c: 
Maintain a task queue for tasks that have been sent out and have not been done by slaves and are ordered
according to ID assigned .
If the deduction of the ID of the current done task is larger than the sum of the ID of the first task 
on the task queue compared and a threshold value, 
send this task to another alive idle slave, remove it from the head of the task queue,
put it at the tail of the task queue,  and change the its ID to the new generated ID.


Another Issues:
1. Maybe one slave is dead and TOP-C is waiting for time out. If slave is working on the last task, timeout never arrives.

Solution:
In topc.c, if master discovers only one task remaining, master sends a PING to
check if socket alive. If not alive, declare slave dead ans reassign that task.

2. Add one status to slave, slow_slave(). 
So a slave could be busy, slow or dead. 
Logic in topc.c:

//===========================
// Anaylyze slow slave to see if it should be dead.
static struct ... *slow_slave = NULL; // initially : task_id: 0;

// call this instead of  slave[rank].dead = 1
void slow_slave(rank) {
   if (slow_slave == NULL) {
     slow_slave = malloc (num_slaves* sizeof(struct ...));
     for i = 0 .. num_slaves-1
        slow_slave[rank].task_id = -1;
   }

   if slave[rank].task_id is equal to slow_slave[rank].task_id  (original task_id)
     // then check if we waited at least one minute
      if time() - slow_slave[rank].current_elapsed_time > 1 minute
         declare slave dead:  slave[rank].dead = 1
      else
         just return, and master will check again on next cycle
   else
      // slave was slow on previous task, but not on current taks
      Reset slow slave[rank] ={slave[rank].task_id: latest current_elapse_time using time() }

}



//===========================
//For the slave that does the last task, it may not read the END_MASTER_SLAVE_TAG. 
The scenario is:
Master: 
1. send out the last task
2. find the slave that is doing the last task timeout, then
	send a ping tag to it to make sure it is still alive.
3. recieve the last task output.
4. send out  END_MASTER_SLAVE_TAG to all slaves.
5. call TOPC_finalize, MPI_finalize: MPI_finalize will colse all sockets.
6. Wait for all zombie processes. 

Slave:
1. receive the task input
2. send out the task result
3. read the PING_TAG.
4. reply with PING_TAG. 

The problem: if slave replies after master has done step 5, slave
observe the dead socket and will not read/write to this socket any more.
So, slave may not read the END_MASTER_SLAVE_TAG and hang there.

Solution:
For slave it just ignores the PING_TAG and continue as usual. 
