I THINK THESE ARE OLD COMMENTS, NO LONGER APPLICABLE.  CHECK AND DELETE.

1. for MPI_Send() :
   in MPINU: don't declare slave_q[]
   in comm-send: if MPI_Send() returns fail, comm-send() return -1,
   in topc.c we can update the slave_q[] according to the return value of 
   comm-send();
2. for MPI_Recv():
It will not update slave_[q] , just return fail.
Although TOPC at this moment doesn't know the slave is dead, but later
when TOPC tries to send a message to this slave, the dead slave will be
detected. Otherwise, when a task times out, master also can detect the dead
slaves.

3. MPINU will get rid of the slave_q[] array.
IN topc.c: we can use slave_array[] instead of slave_q[];
slave_array[] is an array of slave records.
In slave recordd, there is a field, dead, indicating the slave is dead of alive.
If dead == true, then slave is dead , otherwise slave is alive.


4. look at maxID and last_task_id if they are equal.
If equal then use last_task_id instead of maxID.

5. don't need to maintain a task queue.
Let n be the number of slaves.
The idea is:
After every n tasks are done, go over slave_array[] and check every slave is busy 
or idle. If the slave is busy and the task id of that slave is bigger than some
kind of threshold, then resend the task. 
When compute the difference of two ids, we need to consider the wrap arround values.
the difference of two ids: dif1 = |id1 - id2|
dif2 = (id2 + maxid - id1)
if min(dif1, dif2) < threshold, then resend task with id1.


6. 
