\input texinfo.tex   @c -*-texinfo-*-
@c %**start of header
@setfilename topc.info
@settitle TOP-C (Task Oriented Parallel C/C++)
@comment  @setchapternewpage odd   for larger documents and double-sided
@setchapternewpage off
@footnotestyle end
@include topc-version.texi
@comment omit overfull boxes
@finalout
@comment Make a chapter into a section, etc.
@comment @lowersections
@c %**end of header

@iftex
@hbadness=40000
@pretolerance=100000
@tolerance=100000
@end iftex

@comment Decide if actual code, "heart of the TOP-C algorithm"
@comment    makes a better description than current version
@comment    [ or combine two by adding comments to C code ]
@ignore
@{ TOPC_BUF input, output;
  int number_of_idle_slaves = number_of_slaves;
  TOPC_ACTION action;
  do @{
    if ( (input = GenerateTaskInput()) != NOTASK ) @{
      SUBMIT_TO_SLAVE:  output = DoTask(input.data);
      number_of_idle_slaves--;
    @}
    if ( result_is_available(input, output) ) @{
      number_of_idle_slaves++;
      action = CheckTaskResult(input.data, output.data);
      if (action == UPDATE_ACTION)
        UpdateSharedData(input.data, output.data);
    @}
  @} while ( input != NOTASK || number_of_idle_slaves < number_of_slaves );
@}
This simplified excerpt from the @samp{TOP-C} source code describes
the @samp{TOP-C} algorithm..
    TOPC_BUF input, output;
    int num_idle_slaves = num_slaves;
    TOPC_ACTION action;

    while (1) @{
      wait_until_an_idle_slave();
      while ( result_is_available(&input, &output) ) @{
        action = CheckTaskResult(input.data, output.data);
        if (action == UPDATE_ACTION)
          UpdateSharedData(input.data, output.data);
        num_idle_slaves++;
      @}
      input = COMM_generate_task_input();
      if (input.data != NOTASK.data) @{
        SUBMIT_TO_SLAVE:  output = DoTask(input.data);
        num_idle_slaves--;
      @}
      else if (num_idle_slaves < num_slaves) // else insure progress condition
        receive_task_output();               // by blocking until slave reply
      else break;
    @} // termination condition:  last input _after_ all slaves idle was NOTASK

@end ignore
@comment Document ./configure --strip-libs
@comment Explain that any pointer type is acceptable for arguments of callbacks
@comment From .future/manual.dvi, take problems with starting as --mpi
@comment   and add it as appendix (and move existing stuff there).
@comment Add --TOPC-sendahead=0 by default
@comment    and allow it to create at least 1 in advance.
@comment    0 in advance means send out while processing curr. result?
@comment    Note that previous task can still generate REDO,
@comment    CONTINUATION() guaranteed to go to same slave, but possibly
@comment    with an intervening task before the action.
@comment For setpriority(), setrlimit(), etc., re-format for .texi
@comment    and consider making them TOP-C options, or at least --TOPC_nice
@comment Make MSG_CACHE_SIZE a dynamic option based on messages seen,
@comment    and do setsockopt(SO_RCVBUF/SO_SNDBUF) for it.
@comment Use this in tutorial to gradually expand examples.
@comment 1.  no UpdateSharedData,  trivial parallelism
@comment 2.  no UpdateSharedData (with SOFT_ABORT for search)
@comment 3.  no CheckTaskResult, automatic re-check and re-do
@comment ON --mpi, HAVE TO COMPARE INODE/VNODE OF MASTER AND SLAVE
@comment    BINARY, AND WARN IF NOT SAME.
@comment ADD TOPC_master_slave_once( GenerateTaskInput, DoTask, Check... )
@comment AND DEFINE master_slave_chdir(), getstats(), vnode of slave(),
@comment    find getsockopt(SO_RCVBUF) of slave, etc.,
@comment    USING THIS MODE within topc.c
@comment CREATE NOMSG, synonymous with NOTASK??
@comment SHOULD HAVE marshaling functions:
@comment  SetMsgFld("field1",ptr,size); GetMsgFld("field1);
@comment  and require marshaling/unmarshaling in identical order.
@comment  Check that same size fields are unpacked as packed.
@comment LATER, COULD INCLUDE SEPARATE TUTORIAL
@comment    (then add recursion example)
@comment DOCUMENT sendahead when ready (still experimental version only)
@comment ADD FAQ (common questions):
@comment    Why must generate_task_input() be prepared to return
@comment      more than once when there is no more work to do?
@comment    After passing TOP-C an application buffer using TOPC_MSG,
@comment      do I need to free the application buffer, or will TOP-C do that?

@ifinfo
This file documents version @value{VERSION} of
@center @samp{TOP-C} (Task Oriented Parallel C/C++)
@center (last updated @value{UPDATED})
     
@center Copyright (c) 2000 - 2004 Gene Cooperman
     
Permission is granted to make and distribute verbatim
copies of this manual provided the copyright notice and
this permission notice are preserved on all copies.
     
@ignore
Permission is granted to process this file through TeX
and print the results, provided the printed document
carries a copying permission notice identical to this
one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).
     
@end ignore
Permission is granted to copy and distribute modified
versions of this manual under the conditions for
verbatim copying, provided also that the sections
entitled ``Copying'' and ``GNU Lesser General Public License''
are included exactly as in the original, and provided
that the entire resulting derived work is distributed
under the terms of a permission notice identical to this
one.
     
Permission is granted to copy and distribute
translations of this manual into another language,
under the above conditions for modified versions,
except that this permission notice may be stated in a
translation approved by the Free Software Foundation.
@end ifinfo

@ignore
@shorttitlepage TOP-C (Task Oriented Parallel C/C++)
@end ignore

@titlepage

@title TOP-C (Task Oriented Parallel C/C++)
@ifhtml
<IMG SRC="logo.gif" ALT="TOP-C logo">
@end ifhtml
@subtitle A Package for Easily Writing Parallel Applications
@subtitle for both Distributed and Shared Memory Architectures
@subtitle Version @value{VERSION}, @value{UPDATED}
@author Gene Cooperman

     Copyright (c) 2000-2004, Gene Cooperman

     Permission is granted to make and distribute verbatim
     copies of this manual provided the copyright notice and
     this permission notice are preserved on all copies.
     
     Permission is granted to copy and distribute modified
     versions of this manual under the conditions for
     verbatim copying, provided also that the sections
     entitled ``Copying'' and ``GNU General Public License''
     are included exactly as in the original, and provided
     that the entire resulting derived work is distributed
     under the terms of a permission notice identical to this
     one.
     
     Permission is granted to copy and distribute
     translations of this manual into another language,
     under the above conditions for modified versions,
     except that this permission notice may be stated in a
     translation approved by the Free Software Foundation.

     @page
     @vskip 0pt plus 1filll
@end titlepage          

@comment makefile should run install-info after copying info file to dir.
@dircategory Programming
@direntry
* TOP-C: (topc).        TOP-C (Task Oriented Parallel C/C++)
@end direntry

@node Top, Copying, (dir), (dir)
@comment    node-name,         next,       previous, up

@ifinfo
This documents version @value{VERSION} of@*
@samp{TOP-C} (Task Oriented Parallel C/C++),@*
last updated @value{UPDATED}.
@end ifinfo

@menu
* Copying::                     
* Quick Start::                 
* Overview::                    
* Writing TOP-C Applications::  
* Compiling and Invoking TOP-C Applications::  
* Debugging and Tracing::       
* Performance and Long Jobs::   
* Advanced Features::           
* TOP-C Raw Interface::         
* Acknowledgements::            
* Summary::                     
* Example::                     
* Using a Different MPI with TOP-C::
* Function Index::              
* Variable Index::              
* Concept Index::               

 --- The Detailed Node Listing ---

Overview of @samp{TOP-C/C++}

* Programmer Model::            
* Three Key Concepts for TOP-C::  
* Memory Models::               

Programmer's Model

* Structure of a TOP-C Program::  
* Four Callback Functions::     
* Task Buffers::                
* The TOP-C Algorithm::         

Task Input and Task Output Buffers

* Defining Task Buffers::       
* Marshaling::                  

Writing @samp{TOP-C} Applications

* The Main TOP-C Library Calls::  
* Callback Functions::          
* Actions::                     
* TOP-C Utilities::             

Compiling and Invoking @samp{TOP-C} Applications

* Compiling TOP-C Applications::  
* Command Line Options::        
* Invoking a TOP-C Application in Sequential Memory::  
* Invoking a TOP-C Application in Distributed Memory::  
* Invoking a TOP-C Application in Shared Memory::  

Invoking a TOP-C Application in Distributed Memory

* Procgroup Files::             
* Slaves Fail to Start::        

Debugging and Tracing

* Debugging by Limiting Parallelism::  
* Debugging with --TOPC-safety::  
* TOP-C and POSIX signals::            
* Tracing Messages::            
* Stepping Through a Slave::    
* Segmentation faults::         

Performance and Long Jobs

* Strategies for Greater Concurrency::  
* Improving Performance::       
* Long Jobs::                   

Advanced Features of @samp{TOP-C}

* Testing for Task Continuations::  
* Aborting Tasks::              
* Allocation of Task Buffers::  
* Shared Memory Model::         
* Sequential Memory Model::     
* Caveats::                     

Memory Allocation for Task Buffers

* Avoiding malloc::             
* Large Buffers and TOPC_MSG_PTR::  
* Allocation for TOPC_MSG_PTR::  
* Marshaling Complex Data Structures::  

Optimizing TOP-C Code for the Shared Memory Model

* Reader-Writer Synchronization::  
* Thread-Private Global Variables::  
* Volatile Variables::          
* SMP Performance::             

@samp{TOP-C} Raw Interface for Parallelizing Sequential Code

* TOPC-C raw functions::        
* Parallelizing For Loops::     
* Parallelizing While Loops::   
@end menu

@node Copying, Quick Start, Top, Top
@chapter @samp{TOP-C} Copying Conditions

All of the copyright notices of this package are designed to encourage
free copying and usage.  This manual is copyright by Gene Cooperman.
Most of the source code files of the @samp{TOP-C} software package contain
a copyright notice similar to that below.  At the current time, Some of
the source files are copyright by Gene Cooperman alone and some by both
Gene Cooperman and Victor Grinberg, but all files are distributed under
the GNU LGPL license referred to below.

@example
  **********************************************************************
  * Copyright (c) 2000 - 2004 Gene Cooperman <gene@@ccs.neu.edu>        *
  *                                                                    *
  * This library is free software; you can redistribute it and/or      *
  * modify it under the terms of the GNU Lesser General Public         *
  * License as published by the Free Software Foundation; either       *
  * version 2.1 of the License, or (at your option) any later version. *
  *                                                                    *
  * This library is distributed in the hope that it will be useful,    *
  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
  * Lesser General Public License for more details.                    *
  *                                                                    *
  * You should have received a copy of the GNU Lesser General Public   *
  * License along with this library (see file COPYING); if not, write  *
  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
  * 330, Boston, MA 02111-1307 USA, or contact Gene Cooperman          *
  * <gene@@ccs.neu.edu>.                                                *
  **********************************************************************
@end example

@node Quick Start, Overview, Copying, Top
@chapter Quick Start:  Installation and Test Run

@display
   This is version @value{VERSION} of Task Oriented Parallel C/C++ (@samp{TOP-C}).
   See @url{http://www.ccs.neu.edu/home/gene/topc.html} for general
   information on obtaining source, overview slides of @samp{TOP-C},
   previous @samp{TOP-C} applications, etc.
                                                      Gene Cooperman
                                                      @email{gene@@ccs.neu.edu}
@end display

It has been tested and works on several workstation
architectures.  It provides task-oriented parallelism to the end user.
The same application source code (or object code) can be executed
(or linked) with any of the following communication libraries
using the topcc command (a substitute for cc or gcc):
@enumerate
@item a distributed memory library using MPI
    (MPI subset, mpinu, included in distribution); or
@item a shared memory library using threads; or
@item a single-process sequential library
    (useful for development and debugging).
@end enumerate
The @samp{TOP-C} model has been successfully used for some very large
computations.
@comment (See http://www.ccs.neu.edu/home/gene/par-tools.html)

To unpack:
@example
  gunzip topc.tar.gz
  tar xvf topc.tar
  cd topc
  ./configure
  make
@end example

If you are impatient, you can immediately do:
@example
@group
  cd bin
  make parfactor
@end group
@end example
@noindent
and see a demonstration for factoring numbers by a Euclidean sieve.
Then try:  @code{./a.out @var{YOUR_NUMBER}}@*
Read bin/Makefile for an example of compiling a @samp{TOP-C} program.

If you want to use more or different slave processes, modify
@file{bin/procgroup}.
Then, again:
@example
@group
  cd bin
  ./a.out @var{YOUR_NUMBER}
@end group
@end example

And compare with your results using a single slave process:
@example
  ./a.out --TOPC-num-slaves=1 YOUR_NUMBER
@end example
Or investigate what other command-line TOP-C options are available for a.out.
@example
  ./a.out --TOPC-help
@end example

Other TOP-C applications besides parfactor are in the directory
@file{../examples}.  For example, if you would like to try
@file{parquicksort.c}, then from the @file{bin} directory, try:
@example
  make check TEST_FILE=parquicksort
@end example

When you write your own @samp{TOP-C} application, @file{app.c}, make
sure that it contains @code{#include <topc.h>} at the top, and that you
have a procgroup file in the current directory, and then:
@example
@group
  bin/topcc --mpi -o app app.c
  # or else:  bin/topc++ --mpi -o app app.cc
  ./app
@end group
@end example
@noindent
@file{topcc} is a wrapper for your standard C compiler.  It accepts all
the standard compiler command line options, plus a few more.
@file{topc++} also exists.  [NOTE: @code{bin/topcc --help} and
@code{bin/topc++ --help} both work and @file{doc/topcc.1} exists ]

This might be a good point to download and print at least the first half
of the manual, or else make it from the doc directory (@command{cd doc;
make pdf; make ps}).  Note that the table of contents may appear at the
end of the documentation after the index.  See @ref{Summary}, for a list of the
@samp{TOP-C} commands.  See @ref{Example}, for a simple @samp{TOP-C}
example application involving only trivial parallelism.  The
@file{examples} subdirectory provides more detailed examples.
A tutorial is available from the web page,
@url{http://www.ccs.neu.edu/home/gene/topc.html}.

Finally, if you want to install @samp{TOP-C} permanently, type
@example
@group
  ./configure                 # Install in /usr/local
  ./configure --prefix=$HOME  # Install in home directory
  make install
@end group
@end example

This adds a man page, an info file (try @code{info topc}), etc. HTML
documentation is available in the @file{doc} subdirectory of the
@samp{TOP-C} distribution.  By default, @samp{TOP-C} will install in
@file{/usr/local}, requiring root privilege.  If you configure
@code{--prefix=$HOME},
@samp{TOP-C} will create files in @file{$HOME/bin}, @file{$HOME/lib},
@file{$HOME/include}, @file{$HOME/man} and @file{$HOME/info}.
If you want to make @samp{TOP-C} with @code{cc} instead of @code{gcc}, type:
@example
  env CC=cc ./configure --cache-file=/dev/null
@end example
@code{CFLAGS}, @code{CXX} (for @command{topc++} and
@code{CXXFLAGS} can also be set.
For other configuration options, type:
@example
  ./configure --help
@end example

Please write the author, Gene Cooperman (@email{gene@@ccs.neu.edu}), if
there are any questions.

@node Overview, Writing TOP-C Applications, Quick Start, Top
@chapter Overview of @samp{TOP-C/C++}

@comment @flushleft
@display
@cartouche
@noindent
                       "Difficulty?" exclaimed Ford. "Difficulty?  What
                   do you mean difficulty?  [The wheel is] the single
                   simplest machine in the universe!"  ...
                       "All right, Mr. Wiseguy,"  she said,  "you're so
                   clever, you tell us what color it should be."
                       from "The Restaurant at the End of the Universe"
                       by Douglas Adams
@end cartouche
@end display
@comment @end flushleft

@noindent
@samp{TOP-C} has been designed especially to make it easy to parallelize
@emph{existing} sequential applications.  Toward this goal,
@samp{TOP-C} emphasizes:
@enumerate
@item ease of use (high level task-oriented abstraction);
@item latency tolerance; and
@item architecture independence (same application code for
	shared and distributed memory).
@end enumerate

A @samp{TOP-C} application is compiled and run using @command{topcc}
(similarly to @command{gcc}) or @command{topc++} (similarly to @command{g++}).
For example, assuming a @file{procgroup} file in the current
directory to specify the remote hosts for the slave processes,
one executes:
@example
  topcc --mpi parfactor.c
  # or else:  topc++ --mpi parfactor.cc
  ./a.out
@end example

If a @samp{TOP-C} application fails to link, check for a clash of
symbol names.  All TOP-C symbols are of the form
TOPC_*, COMM_*, MEM_*, MPI_*, MPINU_*, NO_ACTION, UPDATE, REDO, CONTINUATION,
or NOTASK.

For purposes of documentation, we will standardize on an explanation of
@command{topcc}.  Wherever @command{topcc} is mentioned, the description is
equally valid for @command{topc++}.

@menu
* Programmer Model::            
* Three Key Concepts for TOP-C::  
* Memory Models::               
@end menu

@node Programmer Model, Three Key Concepts for TOP-C, Overview, Overview
@section Programmer's Model

@menu
* Structure of a TOP-C Program::  
* Four Callback Functions::     
* Task Buffers::                
* The TOP-C Algorithm::         
@end menu

@node Structure of a TOP-C Program, Four Callback Functions, Programmer Model, Programmer Model
@subsection Structure of a TOP-C Program

A typical TOP-C application has the following structure:
@example
#include <topc.h>
... define four callback functions for TOPC_master_slave() ...
int main( int argc, char **argv ) @{
  TOPC_init( &argc, &argv );
  ...
  TOPC_master_slave( GenerateTaskInput, DoTask, CheckTaskResult,
                     UpdateSharedData )
  ...
  TOPC_finalize();
@}
@end example

The program above is run with a master process and several slave processes
operating with identical command line arguments and identical initial
data (SPSD, or Single Program, Single Data).  Communication among processes 
occurs only within the routine @code{TOPC_master_slave()}, during which
execution can be called SPMD (Single Program, Multiple Data).  At the end
of @code{TOPC_master_slave()}, execution returns to SPSD, although the
master process may contain some additional process-private data.

@ref{TOP-C Raw Interface} describes an alternative interface that is
often useful for parallelizing existing sequential code.  However, for
new applications, the standard interface will usually be cleaner.

@node Four Callback Functions, Task Buffers, Structure of a TOP-C Program, Programmer Model
@subsection Four Callback Functions

In a @samp{TOP-C} application, the programmer defines four callback
functions and passes control to the @samp{TOP-C} library through the
following command.
@example
@group
  TOPC_master_slave(GenerateTaskInput, DoTask, CheckTaskResult,
                    UpdateSharedData);
@end group
@end example

Pictorially, TOP-C arranges for the flow of control among the four callback
functions as follows:
@clear for-tex
@iftex
@set for-tex
@end iftex
@comment Have latex version of this, but how to pass it through?
@example
      (ON MASTER)      task input
   GenerateTaskInput() ---------->


  task input   (ON A SLAVE)  task output
  -----------> DoTask(input) ----------->


  task output     (ON MASTER)                    action
  -----------> CheckTaskResult(input, output) ----------->


if (action == UPDATE):
  task input, task output      (ON ALL PROCESSES)
  -----------------------> UpdateSharedData(input, output)
@end example
@ignore
@tex
{\footnotesize
\begin{figure}[htb]\label{topc-fig}
\begin{center}\label{diagram}
\setlength{\unitlength}{3.0pt}
% \setlength{\unitlength}{2pt} % for 2-column mode
\begin{picture}(100,95)
\put(25,90){\makebox(0,0)[b]{\bf MASTER}}
\put(75,90){\makebox(0,0)[b]{\bf SLAVE}}
\put(50,00){\line(0,1){4}}
\multiput(50,15)(0,5){16}{\line(0,1){4}} % 20 times, delta = (0,5)
\thicklines
\put(5,88){\line(1,0){95}}
\put(25,75){\oval(20,10)}  % corner is (35,70)
\put(25,75){\makebox(0,0){\verb|get\_task()|}}
\put(75,55){\oval(25,10)} % corner is (62,5, 50)
\put(75,55){\makebox(0,0){\verb|do\_task(input)|}}
\put(25,32){\oval(45,10)} % corner is (47.5, 26)
\put(25,32){\makebox(0,0){\parbox[t]{90pt}{\verb|get\_task\_result| \hbox{\ \ }\
verb|(output, input)|}}}
\put(50,10){\oval(75,10)}
\put(50,10){\makebox(0,0){\verb|update\_environment(output, input)|}}
\thinlines
% text is near beginning of vector
% ref. point is one corner of oval
\thicklines
\put(34,69){\vector(3,-1){27}} % base is length 20
\put(36,69){\makebox(0,0)[bl]{\verb|input|}}
\put(62,51){\vector(-3,-2){18}} % base is length 20
\put(60,51){\makebox(0,0)[br]{\verb|output|}}
\thinlines
\put(48,37){\vector(3,2){15}} % base is length 20
\put(48,37){\makebox(0,0)[tl]{(if action == {\tt REDO})}}
\put(25,25){\vector(3,-1){25}} % base is length 20
\put(36,22){\makebox(0,0)[bl]{(if action == {\tt UPDATE})}}
\end{picture}\break
  \hbox{\large TOP-C Programmer's Model}
\end{center}
\end{figure}
}
@end tex
@end ignore

@node Task Buffers, The TOP-C Algorithm, Four Callback Functions, Programmer Model
@subsection Task Input and Task Output Buffers

@cindex task input
@cindex task output

A @dfn{task input} or @dfn{task output} is an arbitrary buffer of bytes
of type @code{(void *)} in @samp{TOP-C}.  The task buffers are arbitrary
application-defined data structures, which are opaque to @samp{TOP-C}.
Note that in ANSI C, a void pointer is compatible with any other pointer type
(such as @code{(struct task_input *)} and @code{(struct task_output *)}
in the example below).

@menu
* Defining Task Buffers::       
* Marshaling::                  
* Marshalgen::                  
@end menu

@node Defining Task Buffers, Marshaling, Task Buffers, Task Buffers
@subsubheading Defining Application Task Buffers

An application callback function returning a task input or task output
must encapsulate it in a function, @code{TOPC_MSG( void *@var{buf}, int
@var{buf_size} )}, which is then returned by the callback functions
@code{GenerateTaskInput()} and @code{DoTask()}.  @code{TOPC_MSG()}
internally allocates a copy of @var{buf}, and TOP-C later frees the copy
automatically.  So, @var{buf} may be reused by the application program.

@example
TOPC_BUF DoTask( struct task_input * inp ) @{
  struct task_output outp;
  ...
  outp = ...;
  return TOPC_MSG( &outp, sizeof(outp) );
@}
@end example

The principle of memory allocation in @samp{TOP-C} is that if an
application allocates memory, then it is the responsibility of the
application to free that memory.  @code{TOPC_MSG()} has the further
property of copying its buffer argument to a separate @samp{TOP-C} space
(using a shallow copy), after which the application can free any memory it
allocated.  This happens automatically in the above example,
since @code{outp} is allocated on the stack.

@node Marshaling, Marshalgen, Defining Task Buffers, Task Buffers
@subsubheading Marshaling (Serialization) and Heterogeneous Architectures

@cindex marshaling
@cindex serialization
@cindex heterogeneous architectures

If a heterogeneous
architecture is used, there is an issue of converting data formats
or @dfn{marshaling}.
This is the application's responsibility.  For simple data formats
(integers, floats or characters), such conversion can easily be done
in an ad hoc manner.  Most C compilers use the IEEE binary
floating point standard, and characters are almost always encoded
in eight bit ASCII representation (or possibly in a standard Unicode
format).  Although the byte ordering of integers is not standardized,
the system calls @code{htonl()} and @code{ntohl()} are available
to convert integers into 32 bit @emph{network integers} that are
portable across heterogeneous systems.

For more complicated conversions, one can consider writing one's own
marshaling routines or else using a standard package for marshaling
such as the @samp{XDR} library (RFC 1832, eXternal Data Representation),
@samp{IDL} (@samp{Corba}), or @samp{SOAP} (@samp{XML}).

@node Marshalgen, ,  Marshaling, Task Buffers
@subsubheading Marshalgen, a Package for Marshaling

For complex C++ applications, we recommend tat you try out
@samp{Marshalgen} package.  A pointer to it is available from the TOP-C
home page.  Since the C++ classes to be marshaled are already defined in
@file{.h} files, Marshalgen asks th user simply to annotate those files
with comments (for example, deep copying vs. shallow copying fo
pointers).  @samp{Marshalgen} also has support for such real world
issues as marshalingsubclasses and templates, handling of polymorphism,
etc.  The @samp{Marshalgen} preprocessor then generates methods for a
new marshaling class that know how to marshal and unmarshal the original
class.

@cindex Marshalgen, a package for marshaling

@node The TOP-C Algorithm,  , Task Buffers, Programmer Model
@subsection The @samp{TOP-C} Algorithm

When there is only one slave, 
The @samp{TOP-C} algorithm can be summarized by the
following C code.
@example
@{ void *input, *output;
  TOPC_ACTION action;
  while ( (input = GenerateTaskInput()) != NOTASK ) @{
     do @{
       output = DoTask(input);
       action = CheckTaskResult(input, output);
     @} while (action == REDO);  /* REDO not useful for only one slave */
     if (action == UPDATE) then UpdateSharedData(input, output);
  @}
@}
@end example

On a first reading, it is recommended to skip the rest of this
section until having read through Section @ref{Actions}.

For a better understanding of the case of multiple
slaves, this simplified excerpt from the @samp{TOP-C} source code describes
the @samp{TOP-C} algorithm.
@example
TOPC_BUF input, output;
int num_idle_slaves = num_slaves;
TOPC_ACTION action;

while (TRUE) @{
  wait_until_an_idle_slave();
  input = COMM_generate_task_input();
  if (input.data != NOTASK.data) @{
    SUBMIT_TO_SLAVE:  output = DoTask(input.data);
    num_idle_slaves--;
  @}
  else if (num_idle_slaves < num_slaves) // else insure progress condition
    receive_task_output();               // by blocking until a slave replies
  else break;
@} // termination condition:  _after_ all slaves idle, next input was NOTASK
@end example

The code for @code{wait_until_an_idle_slave()} can be expanded as follows.
@example
void wait_until_an_idle_slave() @{
  do @{
    while ( result_is_available(&input, &output) ) @{
      action = CheckTaskResult(input.data, output.data);
      if (action == UPDATE)
        UpdateSharedData(input.data, output.data);
      if (action == REDO) /* Use updated shared data, when redoing */
        SUBMIT_TO_SLAVE:  output = DoTask(input.data);
      num_idle_slaves++;
    @} while (num_idle_slaves == 0);
  @}
@end example

Note that the term @dfn{result} refers to an @samp{(input,output)} pair.
The routine @code{CheckTaskResult()} returns an @dfn{action}, which
determines the
control structure for a parallel algorithm.  A common definition is:

@example
@group
TOPC_ACTION CheckTaskResult( void *input, void *output ) @{
  if (output == NULL) return NO_ACTION;
  else if ( TOPC_is_up_to_date() ) return UPDATE;
  else return return REDO; @}
@end group
@end example

@code{TOPC_is_up_to_date()} returns true if and only if during the interval
between when the task input was originally generated and when the task
output was returned by the most recent slave, no other slave process had
returned a task output during the interim that had caused the shared data
to be modified through an @code{UPDATE} action.  An @code{UPDATE} action causes
@code{UpdateSharedData()} to be invoked on each process.  Further
discussion can be found in @ref{TOP-C Utilities}.

@node Three Key Concepts for TOP-C, Memory Models, Programmer Model, Overview
@section Three Key Concepts for TOP-C

@cindex task
@cindex shared data
@cindex global shared data
@cindex action
@cindex TOP-C action

    The @samp{TOP-C} programmer's model is based on three key concepts:
@enumerate
@item
 @dfn{tasks} in the context of a master/slave architecture;
@item
 global @dfn{shared data} with lazy updates; and
@item
 @dfn{@var{actions}} to be taken after each task.
@end enumerate

Task descriptions (task inputs) are generated on the master, and assigned to
a slave.  The slave executes the task and returns the result to the master.
The master may update its own private data based on the result, or it may
update data on all processes.  Such global updates take place on each slave
after the slave completes its current task.  Updates are @dfn{lazy} in
that they occur only after a task completes, although it is possible to
issue a non-binding request to @samp{TOP-C} to abort the current tasks
(@ref{Aborting Tasks}).
A SPMD (Single Program Multiple
Data) style of programming is encouraged.

In both shared and distributed memory architectures, one must worry
about the order of reads and writes as multiple slaves autonomously
update data.  The utilities below are meant to ease that chore, by
supporting the ease of the SPMD programming style, while still
maintaining good efficiency and generality for a broad range of
applications.  The software can easily be ported to a variety of
architectures.

@node Memory Models,  , Three Key Concepts for TOP-C, Overview
@section Distributed and Shared Memory Models

@cindex memory model, distributed
@cindex distributed memory model
@cindex SMP

@samp{TOP-C} provides a single API to support three primary memory
models: @dfn{distributed memory}, @dfn{shared memory} and
@dfn{sequential memory}.  (The last model, sequential memory, refers to
a single sequential, non-parallel process.)  On a first reading, one
should think primarily of the distributed memory model (distributed
nodes, each with its own private memory).  Most programs written for
distributed memory will compile without change for sequential memory.
@samp{TOP-C} is designed so that the same application source code may
operate efficiently both under distributed and under shared memory.  In
order to also compile for shared memory hardware (such as SMP),
additional hints to @samp{TOP-C} may be necessary.

In shared memory architectures, @emph{all} data outside of the four
callback functions is shared, by default.  Hence, an @code{UPDATE}
action under shared memory causes only the master process to invoke
@code{UpdateSharedData()}.  To avoid inconsistencies in the data, by
default @samp{TOP-C} arranges that no slave process may run
@code{DoTask()} while @code{UpdateSharedData()} is running.
@samp{TOP-C} also provides support for finer levels of granularity
through application-defined private variables and critical sections.
Further discussion can be found in @ref{Shared Memory Model}.

@node Writing TOP-C Applications, Compiling and Invoking TOP-C Applications, Overview, Top
@chapter Writing @samp{TOP-C} Applications

This chapter assumes a knowledge of the basic concepts in
@ref{Overview}.  In particular, recall @ref{Structure of a TOP-C Program}.

@menu
* The Main TOP-C Library Calls::  
* Callback Functions::          
* Actions::                     
* TOP-C Utilities::             
@end menu

@node The Main TOP-C Library Calls, Callback Functions, Writing TOP-C Applications, Writing TOP-C Applications
@section The Main TOP-C Library Calls

@cindex initializing @samp{TOP-C}
@cindex master-slave mode, invoking
@cindex task input
@cindex task output
@cindex message format, TOPC_MSG()

Every @samp{TOP-C} application must include a @file{topc.h} header, open
with @code{TOPC_init()}, call @code{TOPC_master_slave()} one or more
times, and then close with @code{TOPC_finalize()}.

@display
@code{#include <topc.h>}
      Required at head of any file using TOPC library calls.
@end display
@deftypefun void TOPC_init ( int *@var{argc}, char ***@var{argv} )
       Required before first occurrence of @code{TOPC_master_slave()};
       Recommended to place this as first executable statement in
         @code{main()}.  It will strip off extra @samp{TOP-C} and
         communication layer arguments such as @option{--TOPC-stats},
         which are added by @samp{TOP-C}.
@end deftypefun
@deftypefun void TOPC_finalize ( void )
       Placed after last @samp{TOP-C} command.
@end deftypefun
@deftypefun void TOPC_master_slave
  ( TOPC_BUF (*@var{generate_task_input})(),@*@ @
    TOPC_BUF (*@var{do_task})(void *input),@*@ @
    TOPC_ACTION (*@var{check_task_result})(void *input, void *output),@*@ @
    void (*@var{update_shared_data})(void *input, void *output)
  @*)
      @*Primary call, passed four application callbacks to @samp{TOP-C}.
        One can have multiple calls to
        @code{TOPC_master_slave()}, each invoking different callback functions,
        between @code{TOPC_init()}
        and @code{TOPC_finalize()}.
@end deftypefun

@sp 1
A task input or task output is simply a buffer of bytes, specified by
@code{TOPC_MSG()}.

@deftypefun TOPC_BUF TOPC_MSG ( void *@var{buf}, int @var{buf_size} )
        Must be returned by @code{GenerateTaskInput()} and @code{DoTask()}.
        Specifies arbitrary user data structure.
        @samp{TOP-C} will make a copy of @var{buf} in @samp{TOP-C} space.
        It remains the responsibility of the application to free or
	reuse the space of the original buffer @var{buf}.  If
	@code{TOPC_MSG(NULL, 0)} is called, a @code{NULL} pointer will be
	received at the destination.
	(@xref{Large Buffers and TOPC_MSG_PTR}, for @code{TOPC_MSG_PTR},
	to avoid copying very large buffers, where the overhead is
	unacceptable.)
@end deftypefun

@noindent
EXAMPLE:
@example
@group
    TOPC_BUF convert_string_to_msg( char *mystring ) @{
        if (mystring == NULL) return TOPC_MSG(NULL,0);
        else return TOPC_MSG(mystring, strlen(mystring)+1);
    @}
@end group
@end example

@node Callback Functions, Actions, The Main TOP-C Library Calls, Writing TOP-C Applications
@section Callback Functions for @code{TOPC_master_slave()}

The application writer must define the following four callback functions
(although the last can be @code{NULL}).  The @var{callback} terminology
is based on C@w{ }concepts.  In a more object-oriented style, one would
view user callbacks as instantiation of abstract methods in a
user-defined subclass.  The first two functions return a
@code{TOPC_BUF}, which is produced by @code{TOPC_MSG()}.
@deftypefun TOPC_BUF GenerateTaskInput ( void )
        executes on master; returns a data structure specified by
        @code{TOPC_MSG(@var{buf}, @var{buf_size})}.
        It should return @code{NOTASK}, when there are no more tasks, and it
        should be prepared to return @code{NOTASK} again if invoked again.
@end deftypefun
@deftypefun TOPC_BUF DoTask ( void *@var{input} )
        executes on slave; operates on the result of @code{GenerateTaskInput()};
        returns a data structure specified by
        @code{TOPC_MSG(@var{buf}, @var{buf_size})}.
        @var{buf} must be a static or global user buffer.
@end deftypefun
@deftypefun TOPC_ACTION CheckTaskResult ( void *@var{input}, void *@var{output})
        executes on master; operates on the result of @code{DoTask()};
        returns an @var{ACTION} that determines what happens to the task next.
        The terminology @dfn{result} refers to an @samp{(input, output)} pair.
        An easy way to write @code{CheckTaskResult()} appears in the
        example for the utility @code{TOPC_is_up_to_date()}.
        When returning the action @code{UPDATE}, it works to first modify
        the input and output buffers.  @code{UpdateSharedData()} will
        then be invoked with the modified buffers.
        See @ref{TOP-C Utilities}, for more details.
@end deftypefun
@deftypefun void UpdateSharedData ( void *@var{input}, void *@var{output} )
        executes on master and all slaves; operates on the result of
        @code{DoTask()}, and the original task returned by
        @code{GenerateTaskInput()};
        called only if @code{CheckTaskResult()} returned @code{UPDATE};
        useful for updating global variables in all processes;
        The pointer argument, @var{update_shared_data}, of
        @code{TOPC_master_slave()} may be @code{NULL} if
        an application never requests an @code{UPDATE} action.
        In a shared memory environment, only the master calls
        @code{UpdateSharedData()}.  See @ref{Shared Memory
        Model}, for more details.
@end deftypefun

Note that in defining the above callback functions, C allows one to
replace the @code{(void *)} declaration of the arguments by specific
pointer types.  Note that the buffers of any message parameters
(@var{input} and @var{output}) of @code{DoTask()} or
@code{CheckTaskResult()} are part of TOP-C space.  Such buffers may be
freed by TOP-C on exit from the callback function.  An application
wishing to use the buffer after the callback exits must explicitly save
a copy into the application's own space.

@node Actions, TOP-C Utilities, Callback Functions, Writing TOP-C Applications
@section Actions Returned by @code{CheckTaskResult()}

@cindex actions returned by @code{CheckTaskResult()}

A @dfn{TOP-C result} is an  (@var{input}, @var{output}) pair corresponding
to an invocation of @code{DoTask()}.  @samp{TOP-C} passes the result to
@code{CheckTaskResult()}.  The return value allows the application to
tell @samp{TOP-C} what further actions to take.
The actions returned by @code{CheckTaskResult()} are:
@deftypevr Action TOPC_ACTION NO_ACTION
  C constant, causing no further action for task
@end deftypevr
@deftypevr Action TOPC_ACTION UPDATE
  C constant, invoking @code{UpdateSharedData( void *@var{input},
  void *@var{output})}  (see below)
  also updates bookkeeping for sake of @code{TOPC_is_up_to_date()}
  (@pxref{TOP-C Utilities})
@end deftypevr
@deftypevr Action TOPC_ACTION REDO
          Invoke @code{DoTask()} on original task input again, and on
          the same slave that previously executed the task; useful if
	  shared data has changed since original
          invocation of @code{DoTask()} (see @code{TOPC_is_up_to_date()},
          below).  See @ref{Strategies for Greater Concurrency},
	  for slave strategies to efficiently process a @code{REDO} action.
@end deftypevr
@comment Small lie that this is a variable, but we don't want it w/ fnc's
@deftypevr Action TOPC_ACTION CONTINUATION ( void *@var{next_input} )
        @code{CONTINUATION(@var{next_input})} is a parametrized action that
	may be returned by @code{CheckTaskResult()}, after which
        @code{DoTask( @var{next_input} )} is called on the original slave.
        This is useful if only the master can decide whether task is complete,
	or if the master wishes to supply additional input messages
	needed for the task.
	Note that @code{REDO} is essentially equivalent to
	@code{CONTINUATION( @var{original_task_input} )}.
        Note that any pending calls to @code{UpdateSharedData()} will have
        occurred on the slave before the new call to @code{DoTask()}.
        Hence, this allows an extended conversation between master and
        slave, in which the slave continues to receive updates of the
        shared data before each new input from the master.
        Note also that even though a @code{CONTINUATION} action returns
        to the original slave, any previous pointers to input buffers
	on that slave
        (and pointers to output buffers from intervening @code{UPDATE}
        actions) will no longer be valid.  Useful data from previous buffers
        should have been copied into global variables on the slave.
        In the case of the shared memory model, those global variables must be
        thread-private.  (@pxref{Thread-Private Global Variables})
@end deftypevr

It is possible for @code{CheckTaskResult(@var{input}, @var{output})} to
modify the buffer data in its two arguments, @var{input} and @var{output},
in which case the modifications will be visible to any further
callback functions processing the current task.  This practice makes
the code more difficult to maintain, and is not recommended when other
solutions are available.

@node TOP-C Utilities,  , Actions, Writing TOP-C Applications
@section TOP-C Utilities

@samp{TOP-C} also defines some utilities.
@deftypefun TOPC_BOOL TOPC_is_up_to_date ( void )
        returns TRUE or FALSE (1 or 0); returns TRUE if and only if
        @code{CheckTaskResult()}
        has not returned the result @code{UPDATE} (invoking
        @code{UpdateSharedData()})
        between the time when @code{GenerateTaskInput()} was originally
        called on the
        current task, and the time when the corresponding
        @code{CheckTaskResult()}
        was called.
        Typical usage:
@example
          TOPC_ACTION CheckTaskResult( void *input, void *output )
          @{ if (input == NULL) return NO_ACTION;
            else if (TOPC_is_up_to_date()) return UPDATE;
            else return REDO;
          @}@
@end example
@end deftypefun
@deftypefun int TOPC_rank ( void )
        Unique ID of process or thread.  Master always has rank 0.
        Slaves have contiguous ranks, beginning at 1.
@end deftypefun
@deftypefun TOPC_BOOL TOPC_is_master ( void )
        Returns boolean, 0 or 1, depending on if this is master.
        Equivalent to @code{TOPC_rank() == 0}.
@end deftypefun
@deftypefun int TOPC_num_slaves ( void )
        Total number of slaves.
@end deftypefun
@deftypefun int TOPC_num_idle_slaves ( void )
        Total number of idle slaves (not doing task, update or other action).
@end deftypefun
@deftypefun int TOPC_node_count ( void )
        Total number of processes or threads.  Equivalent to
        @code{TOPC_num_slaves() + 1}.
@end deftypefun

@deftypefun TOPC_BOOL TOPC_is_REDO ( void )
@deftypefunx TOPC_BOOL TOPC_is_CONTINUATION ( void )
@deftypefunx void TOPC_abort_tasks ( void )
@deftypefunx TOPC_BOOL TOPC_is_abort_pending ( void )
	See @ref{Advanced Features} for descriptions.
@end deftypefun

@node Compiling and Invoking TOP-C Applications, Debugging and Tracing, Writing TOP-C Applications, Top
@chapter Compiling and Invoking @samp{TOP-C} Applications

A @samp{TOP-C} application can be compiled once, and then linked to your
choice of a run-time library for either a sequential, distributed memory
or shared memory architecture.  The two shell scripts @file{bin/topcc}
and @file{bin/topc++} are used instead of @samp{gcc} and @samp{g++} (or
other C/C++ compilers).

@menu
* Compiling TOP-C Applications::  
* Command Line Options::        
* Invoking a TOP-C Application in Sequential Memory::  
* Invoking a TOP-C Application in Distributed Memory::  
* Invoking a TOP-C Application in Shared Memory::  
@end menu

@node Compiling TOP-C Applications, Command Line Options, Compiling and Invoking TOP-C Applications, Compiling and Invoking TOP-C Applications
@section Compiling TOP-C Applications

@cindex topcc
@cindex topc++
@cindex topc-config

The TOP-C application file must contain
@example
    #include <topc.h>
@end example
@noindent
It must make calls to
@example
@group
    TOPC_init(...);
    TOPC_master_slave(...);
    TOPC_finalize();
@end group
@end example
@noindent
as describe in @ref{Structure of a TOP-C Program}.  The
application file is compiled by one of:
@example
@group
    topcc --seq @var{myfile.c}
    topcc --mpi @var{myfile.c}
    topcc --pthread @var{myfile.c}
@end group
@end example
@noindent
according to whether the target computer architecture will be sequential
(@option{--seq}:  single processor), distributed memory (@option{--mpi}:
networked CPU's), or shared memory (@option{--pthread}:  SMP or other
shared memory architecture with a POSIX threads interface).
@command{topcc} is a substitute for @command{cc} or @command{gcc},
and creates an @samp{a.out} file.
(Similarly, @command{topc++} exists as a substitute for @command{c++} or
@command{g++}.)
There are man files,
@display
    @file{doc/topcc.1},   @file{doc,topc++.1}
@end display
@noindent
with further information on @command{topcc} and @command{topc++}.
If installed, @command{man topcc} and @command{man topc++} exist.

The same object file may be relinked to use different @samp{TOP-C} memory
models without recompiling the object file.
@example
@group
    topcc -c @var{myapp.c}
    topcc --seq -o @var{myapp-seq} @var{myapp.o}
    topcc --mpi -o @var{myapp-mpi} @var{myapp.o}
@end group
@end example

For large applications, it may be preferable to directly invoke
the @samp{TOP-C} libraries and include files.  For such
situations, @command{topc-config} exists.  The following
is exactly equivalent to @command{topcc --mpi myfile.c}
(assuming you configured @samp{TOP-C} using @command{gcc}).
@example
    gcc `topc-config --cflags` --mpi myfile.c `topc-config --libs`
@end example
Type @command{topc-config} with no arguments for a full set of
command line options.

For the rest of this chapter, we standardize our description for
@command{topcc}.  However, @command{topc++} is equally valid wherever
@command{topcc} is mentioned.

@node Command Line Options, Invoking a TOP-C Application in Sequential Memory, Compiling TOP-C Applications, Compiling and Invoking TOP-C Applications
@section Command Line Options in TOP-C Applications

@cindex TOP-C options
@cindex TOP-C command line options
@vindex TOPC_OPTS
@cindex TOPC_OPTS environment variable for initialization
@cindex .topcrc
@cindex topcrc
@cindex options, TOP-C
@cindex command line options, TOP-C
@cindex --TOPC-help
@cindex --TOPC-verbose
@cindex --TOPC-stats
@cindex --TOPC-num-slaves
@cindex --TOPC-aggregated-tasks
@cindex --TOPC-slave-wait
@cindex --TOPC-slave-timeout
@cindex --TOPC-trace
@cindex --TOPC-procgroup
@cindex --TOPC-safety

TOP-C searches for TOP-C parameters in the following locations, in order:
@enumerate
@item values of variables @code{TOPC_OPT_xxx} in the application code
	before @code{TOPC_init()}
@item the file @file{.topcrc} in the home directory
@item the environment variable @env{TOPC_OPTS}
@item arguments on the command line in the form @code{--TOPC-xxx}
@end enumerate
The file @file{.topcrc} and the environment variable @env{TOPC_OPTS}
specify parameters
in the same format as on the command line.  Later assignments of an
option override earlier assignments.

For a brief synopsis of application command line options, type:
@example
@group
    topcc @var{myapp.c}
    ./a.out --TOPC-help
    [ OR FOR MORE INFORMATION:  ./a.out --TOPC-help --TOPC-verbose  ]
@end group
@end example

Currently, this will display the following.
@example
Usage:  ./a.out [TOPC_OPTION ...] [OTHER_OPTIONS ...]

  where TOPC_OPTION is one of:
--TOPC-help@code{[=<0/1>]}        display this message   [default: false]
--TOPC-stats@code{[=<0/1>]}       print stats before & after [default: false]
--TOPC-verbose@code{[=<0/1>]}     set verbose mode       [default: false]
--TOPC-num-slaves@code{=<int>}    number of slaves (sys-defined default) 
                                                   [default: -1]
--TOPC-aggregated-tasks@code{=<int>} number of tasks to aggregate 
                                                   [default: 1]
--TOPC-slave-wait=@code{<int>}    secs before slave starts (use w/ gdb attach)
                                                   [default: 0]
--TOPC-slave-timeout=@code{<int>} dist mem: secs to die if no msgs, 0=never
                                                   [default: 1800]
--TOPC-trace@code{=<int>}         trace (0: notrace, 1: trace, 2: user trace fncs.) 
                                                   [default: 2]
--TOPC-procgroup@code{=<string>}  procgroup file (--mpi)
                                                   [default: "./procgroup"]
--TOPC-topc-log@code{=<string>}   NOT IMPL: log file for TOPC output ("-" = stdout) 
                                                   [default: "-"]
--TOPC-safety=@code{<int>}        [0..20]: higher turns off optimizations,
                         (try with --TOPC-verbose) [default: 0]
@end example

For each option, @option{--TOPC-@var{PARAM}}, there is a corresponding
C/C++ variable, @code{TOPC_OPT_@var{PARAM}}.  This variable is of type
@code{int} or @code{(char *)}.  If the application program sets the value
before a call to @code{TOPC_init()}, these variables will act as
defaults.  For example, to turn off tracing by default, write:
@example
@group
int main( int argc, char *argv[] ) @{
  TOPC_OPT_trace = 0;
  TOPC_init( &argc, &argv );
  ...
@end group
@}
@end example

The option @option{--TOPC-trace} causes the task input and task output
to be traced and printed as they are passed across the network.  The action of
a task is also printed.  If an application is called with
@option{--TOPC-trace=2} (default) and if the variables
@code{TOPC_OPT_trace_input} and @code{TOPC_OPT_trace_result} are set
to pointers to
functions then those functions are called, and they may print additional
information.
@code{TOPC_OPT_trace_input} must be set to a function of one
variable:  @code{void * @var{input}}.
@code{TOPC_OPT_trace_result} must be set to a function of two
variables:  @code{void * @var{input}, void * @var{output}}.
When using C++, the function pointers must be cast to
@code{TOPC_trace_input_ptr} or @code{TOPC_trace_result_ptr}
before being assigned to @code{TOPC_OPT_trace_input} or
@code{TOPC_OPT_trace_result}, respectively.
For an example, see @file{examples/parfactor.c} in the TOP-C distribution.

The option @option{--TOPC-stats} prints statistics (running times,
etc.) and
information about the conditions of an invocation of a TOP-C application
before and after a run.
The option @option{--TOPC-verbose} (set by default) displays TOP-C
warnings.  With --TOPC-help, it provides additional information.

For the usage of @option{--TOPC-procgroup},
see @ref{Invoking a TOP-C Application in Distributed Memory}.
That section also explains on what hosts the slaves run
when @option{--TOPC-num-slaves} indicates a different number of
slaves than the @file{procgroup} file.

For the usage of @option{--TOPC-aggregated-tasks},
see @ref{Improving Performance}.
For the usage of @option{--TOPC-slave-wait}, see
@ref{Stepping Through a Slave}.
For the usage of @option{--TOPC-safety}, see
@ref{Command Line Options}.
For the usage of the other options, see the @ref{Concept Index}.

@samp{TOP-C} recognizes @code{--} as terminating all option processing,
according to standard UNIX conventions.

@node Invoking a TOP-C Application in Sequential Memory, Invoking a TOP-C Application in Distributed Memory, Command Line Options, Compiling and Invoking TOP-C Applications
@section Invoking a TOP-C Application in Sequential Memory

@cindex memory model, sequential, compiling
@cindex compiling the sequential memory model
@cindex --seq argument to @code{topcc/topc++}

For example,
@example
    topcc --seq -g -O0 @var{myfile.c}
@end example
@noindent
compiles a sequential version for debugging using @command{gdb}
(@pxref{Top, , Summary, gdb, The GNU debugger}), for example.
This is usually a first step in debugging a TOP-C application, since
sequential debugging is easier than parallel debugging.

@node Invoking a TOP-C Application in Distributed Memory, Invoking a TOP-C Application in Shared Memory, Invoking a TOP-C Application in Sequential Memory, Compiling and Invoking TOP-C Applications
@section Invoking a TOP-C Application in Distributed Memory

@cindex memory model, distributed, compiling
@cindex compiling the distributed memory model
@cindex --mpi argument to @code{topcc/topc++}

Linking using the @option{--mpi} option (default) allows an application to
execute using a distributed memory model of networked processors.  The
@samp{TOP-C} distribution includes a subset MPI@footnote{MPI is
@emph{Message Passing Interface}, see @url{http://www.mpi-forum.org/}}
implementation @samp{MPINU}, sufficient to run @samp{TOP-C}
applications.
@example
@group
  topcc --mpi @var{myapp.c}
  ./a.out
@end group
@end example
The application must then create the remote slave processes at runtime.
If you use @samp{MPINU} (the default configuration of @samp{TOP-C},
then the remote slave processes are specified by a @file{procgroup} file.
Otherwise, the startup mechanism depends on your @samp{MPI} implementation.

@menu
* Procgroup Files::             
* Slaves Fail to Start::        
@end menu

@node Procgroup Files, Slaves Fail to Start, Invoking a TOP-C Application in Distributed Memory, Invoking a TOP-C Application in Distributed Memory
@subsection Writing Procgroup Files for @samp{MPINU}

@cindex MPINU
@cindex SSH environment variable for starting remote slaves
@cindex procgroup file
@cindex --TOPC-procgroup, usage of procgroup file
@cindex --TOPC-num-slaves, selection of slave hosts using procgroup file

@samp{MPINU} is built into the default configuration of the
@samp{TOP-C} library and uses the @samp{procgroup} mechanism to specify
slave processes.  (If you prefer to use a different @samp{MPI} dialect,
@samp{TOP-C} will work, but @file{src/Makefile.in} must be modified,
and that @samp{MPI} dialect may use a different mechanism for
introducing slave processes.)

When the application binary is executed under the default, it looks at
the current directory for a file,
@display
    @file{procgroup}
@end display
The @var{procgroup file} determines the number and location of the slave
processes.  The @var{procgroup file} need only be visible from the
master process.  If one prefers, one can specify an alternate
@var{procgroup file} via the syntax as in the following example:
@example
    ./a.out --TOPC-procgroup=../myprocgroup.big
@end example

The @samp{TOP-C} distribution includes a file @file{bin/procgroup} as an
example of the  procgroup format.
The file must contain a line:
@example
    local 0
@end example
@noindent
for the master process.  It must also contain a line for each slave
process in one of the following forms:
@example
    hostname 1 @var{full_pathname}
    hostname 1 -
    hostname 1 ./@var{relative_pathname}
    hostname 1 ../@var{relative_pathname}
@end example
@noindent
where @code{hostname} is the remote host.  
The pathname @code{-} means to use the same pathname for the slave
on the remote host as for the master on the current host.
A relative pathname, such as @code{./a.out} or @code{../new_arch/a.out},
specifies a pathname relative to the pathname of the binary of
the master on the current host.

Most of the time, it is simplest to just include a full pathname
or else @code{-} in the @file{procgroup} file.  The relative pathnames are
useful for a shared filesystem with binaries compiled for
different architectures.  For example, the procgroup file might include
relative paths @file{../sparc/a.out}, @file{../alpha/a.out} and
@file{../linux/a.out}.
If you invoke @file{full_path/sparc/a.out}, this will yield a master
running @file{full_path/sparc/a.out} and three slaves running
each of the three architectures.

The full principles are as follows.
Let SLAVE_PATH be the path of the slave as given in the procgroup file,
and let MASTER_DIR be the directory of the master process as invoked on
on the command line. 
@example
SLAVE_PATH absolute:
  slave binary image is SLAVE_PATH
SLAVE_PATH relative and MASTER_DIR absolute:
  slave binary image is MASTER_DIR/SLAVE_PATH
SLAVE_PATH relative and MASTER_DIR relative:
  slave binary image is $PWD/MASTER_DIR/SLAVE_PATH
SLAVE_PATH is - and master process invoked on command line as MASTER_BIN:
  slave binary image is MASTER_BIN  (if MASTER_BIN is absolute path)
  or $PWD/MASTER_BIN (if MASTER_BIN is relative path)
If the procgroup line contains command line arguments,
  those command line arguments are passed to the slave application
  as its first arguments, and any arguments on the master command
  line are appended to the list of arguments.
@end example
TOP-C assumes that your
application does not change the working directory before
calling @code{TOPC_init()}.

By default, @samp{TOP-C} uses the procgroup file in the current directory.
You can choose an explicit procgroup file via a program
variable, @code{TOPC_OPT_procgroup="/project/myprocgroup";}, or via a
command-line option,
@code{/project/sparc/app --TOPC-procgroup=/project/myprocgroup}.
@xref{Command Line Options}.

If the command line option @option{--TOPC-num-slaves=@var{int}}
is given, and if @var{int} is less than the number of
slaves in the @file{procgroup} file, then @samp{TOP-C} will
use the first @var{int} slaves from the file.  If @var{int}
is more than the number of slaves in the @file{procgroup} file,
then @samp{TOP-C} will use all of the given slaves, and then
create additional processes on the remote hosts, by
returning to the beginning of the @file{procgroup} file and
re-reading the list of slave host/binaries until @var{int}
slaves have been created in all.

It is recommended to use only @code{localhost} during initial
development.

@vindex SSH

The environment variable, @env{SSH} (default value @code{ssh}) is used to
invoke the remote host.  If, for example, your site uses @code{rsh}
instead of @code{ssh}, the following code, when executed
before @code{TOPC_init()} will produce this effect.
@example
  putenv("SSH=rsh");
@end example
Alternatively, type @command{SSH=rsh} (sh/bash, etc.) or
@command{setenv SSH rsh}
(csh/tcsh, etc.) in the UNIX shell before invoking the TOP-C application.

@node Slaves Fail to Start,  , Procgroup Files, Invoking a TOP-C Application in Distributed Memory
@subsection If Slaves Fail to Start

@vindex /tmp/mpinu-ssh
@cindex debugging @samp{TOP-C} @option{--mpi} applications that fail to start
@cindex distributed memory, fails to start
@cindex mpinu-ssh for debugging slave startup
@cindex slave startup in distributed memory, difficulties

If some slave processes start, but not others, then try executing
the following simple program.
@example
#include "topc.h"
int main(int argc, char *argv) @{
  char host[100];
  printf("%s connecting ...\n", gethostname(host, 99));
  TOPC_init(&argc, &argv);
  printf("... %s connected.\n", gethostname(host, 99));
  TOPC_finalize();
@}
@end example

If the slave processes fail to start up or fail to respond to the master
and if you are using @samp{MPINU} (default configuration of @samp{TOP-C},
 one other debugging resource is available.
If an application fails to start up, then @samp{TOP-C} leaves in
the @file{/tmp} directory a file
@display
    @file{/tmp/mpinu-ssh.$$}
@end display
where @code{$$} is the process id.  The file shows the commands that
@samp{TOP-C/mpinu} tried to use to start up the slave process.  By
examining and even manually executing those commands from the terminal,
one can often deduce the difficulty in creating the slave processes.

Test the ability of your computer facility to execute remote processes
@emph{without passwords} by typing:  @code{ssh REMOTE_HOST pwd}.
If the problem is that @code{ssh} is not working, try setting
the environment variable @env{SSH} to @code{ssh} or other site-specific
setting.
@xref{Procgroup Files}.

If you are using @code{ssh} (default if the environment variable
@env{SSH} is not set), and if it requires a password then the following
commands within UNIX may allow ssh to operate on your local cluster
without passwords.
@example
ssh-keygen -t dsa       [accept default values]
ssh-keygen -t rsa       [accept default values]
cat ~/.ssh/id*.pub >> ~/.ssh/authorized_keys
@end example
For security, be sure that ~/.ssh has no read permission for other users.

@node Invoking a TOP-C Application in Shared Memory,  , Invoking a TOP-C Application in Distributed Memory, Compiling and Invoking TOP-C Applications
@section Invoking a TOP-C Application in Shared Memory

@cindex memory model, shared, compiling
@cindex compiling the shared memory model
@cindex --pthread argument to @code{topcc/topc++}

Linking using the @option{--pthread} option allows an
application to execute using POSIX threads.
Note that the @samp{TOP-C} memory model for shared memory has some small
variations from the distributed memory model.
The largest potential
source of incompatibility is if your @code{DoTask()} routine modifies
any global or static variables.  If so, such variables will
need to be declared @dfn{thread private}.
Check your source code to see if this
affects you.

Second, if you encounter insufficient performance, you may consider
experimenting with @emph{fine grain thread parallelism}.  The default
@samp{TOP-C} algorithm for shared memory allows @code{UpdateSharedData()}
to begin executing only after each current invocation of @code{DoTask()}
completes.  This can be modified by an application for
finer grain parallelism.  @xref{Shared Memory
Model, @samp{TOP-C} Shared Memory Model, Optimizing TOP-C Code for
the Shared Memory Model}, for details in either of the above cases.

Note also that while a @samp{TOP-C} application object file can usually be
linked using an arbitrary @samp{TOP-C} memory model without recompiling,
there are some circumstances where you may first need to recompile the
application source using @command{topcc --pthread}.

@node Debugging and Tracing, Performance and Long Jobs, Compiling and Invoking TOP-C Applications, Top
@chapter Debugging and Tracing

@cindex debugging
@cindex SIGPIPE signal handler not recognized

If the difficulty is that the application fails to start in the distributed
memory model (using @command{topcc --mpi}), then read
@ref{Slaves Fail to Start}, for some
debugging techniques.  Note also that TOP-C ignores SIGPIPE.  This is
because TOP-C employs the SO_KEEPALIVE option, and the master process
would otherwise die if a slave process were to die.  SO_KEEPALIVE
is needed for robustness when slave processes execute long tasks without
communicating with the master process.
The rest of this section assumes that the
application starts up correctly.

@menu
* Debugging by Limiting Parallelism::  
* Debugging with --TOPC-safety::  
* TOP-C and POSIX signals::            
* Tracing Messages:: 
* Stepping Through a Slave:: 
* Segmentation faults:: 
@end menu

@node Debugging by Limiting Parallelism, Debugging with --TOPC-safety, Debugging and Tracing, Debugging and Tracing
@section Debugging by Limiting the Parallelism
@cindex --TOPC-num-slaves, example

First, compile and link your code
using @command{topcc --seq --TOPC-safety=20 -g -O0},
and make sure that your application works correctly sequentially.  Only after
you have confidence in the correctness of the sequential code, should you
begin to debug the parallel version.

If the application works correctly in sequential mode, one should debug
in the context of a single slave.  It is convenient to declare the
remote slave to be @code{localhost} in the @file{procgroup} file, in order
to minimize network delays and so as not to disturb users of
other machines.  In this case, the code is ``almost''
sequential.  An easy way to do this is:
@example
  topcc --mpi --TOPC-num-slaves=1 -g -O0
@end example

Next, one should test on two slaves, and finally all possible slaves.

@node Debugging with --TOPC-safety, TOP-C and POSIX signals, Debugging by Limiting Parallelism, Debugging and Tracing
@section Debugging with @option{--TOPC-safety}

@cindex --TOPC-safety for debugging
@cindex debugging, --TOPC-safety

The command-line option @option{--TOPC-safety=@var{val}} provides assistance
for debugging parallel programs.  At higher values of @var{val},
optimizations that do not change the correctness of the program are
converted to safer equivalents.  A good strategy is to
test if @option{--TOPC-safety=20} causes the bug to go away, and if so,
progressively lower @var{val} toward zero, until the bug reappears.
The value at which the bug reappears indicates what @samp{TOP-C}
optimization feature is not being used correctly.  If the bug still
exists at @option{--TOPC-safety=20}, one should next try compiling
with the @option{--seq} flag and use a debugger to debug the sequential code.

The effects due to different safety levels are subject to change.
To see the current effects, invoke any TOP-C application as follows
@example
  ./a.out --TOPC-help --TOPC-verbose
@end example
and you will see something like:
@example
  safety: >=0: all; >=2: no TOP-C memory mgr (uses malloc/free);
  >=4: no TOPC_MSG_PTR; >=8: no aggreg.;
  >=12: no TOPC_abort_tasks; >=14: no receive thread on slave;
  >=16: default atomic read/write for DoTask, UpdateSharedData;
   =19: only 2 slaves; >=20: only 1 slave
  (AGGREGATION NOT YET IMPLEMENTED)
@end example

Values higher than 4 cause @code{TOPC_MSG_PTR()} to act as
if @code{TOPC_MSG()} was called instead.
Values higher than 12 cause @code{TOPC_abort_tasks()} to have no effect.
Values higher than 14 imply that a single thread in the slave process
must receive messages and execute @code{DoTask()}.  Normally,
@samp{TOP-C} arranges to overlap communication and computation on the
slave by setting up a separate thread to receive and store messages from
the master.
Values higher than 15 imply that @samp{TOP-C} will use malloc instead
of trying to do its
own memory allocation (which is optimized for @samp{TOP-C} memory
patterns).
Values higher than 16 imply that all of @code{DoTask} acts as
if a read lock was placed around it, and all of @code{UpdateSharedData}
has a write lock placed aound it.  (This has an effect only
in the shared memory model where calls to @code{TOPC_ATOMIC_READ/WRITE}
are ignored.)
At values of 19 and 20, the number of slaves is reduced to
2 and to 1, regardless of the setting of @option{--TOPC-num-slaves}
and the specification in a @file{procgroup} file.

@node TOP-C and POSIX signals, Tracing Messages, Debugging with --TOPC-safety, Debugging and Tracing
@section TOP-C and POSIX signals
@cindex signals and TOP-C
@cindex SIGPIPE
@cindex SIGPINT
@cindex SIGALRM

If an application handles its own signals, this can create a clash
with the TOP-C.
In the distributed memory model (--mpi), @samp{TOP-C} will create its own
signal handlers for @code{SIGALRM}.  This is used in conjunction with
@code{alarm()} to eventually kill runaway
slave processes.  In addition, if using @samp{MPINU},
the built-in MPI subset, @samp{TOP-C} will create its own handler
for @code{SIGPIPE}.  This is in order to allow the master
process to detect dead sockets, indicating dead slaves.
Finally, for short periods, @samp{MPINU}
will disable the use of @code{SIGINT} around calls to @code{select()}.
Nevertheless, if a SIGINT is sent during this period, TOP-C will pass the
signal on to the original SIGINT handler of the application.

@samp{TOP-C} does not modify signal handlers in the sequential (--seq)
or shared memory (--pthread) models.  Furthermore, if a different
MPI (other than MPINU) is used with TOP-C, TOP-C will only handle
@code{SIGALRM}.  However, the other MPI may handle signals itself.
@xref{Using a Different MPI with TOP-C}.

@node Tracing Messages, Stepping Through a Slave, TOP-C and POSIX signals, Debugging and Tracing
@section Tracing Messages

@cindex TOPC_OPT_trace, usage for dynamically debugging messages
@cindex TOPC_OPT_trace_input
@cindex TOPC_OPT_trace_result

If a bug appears as one moves to greater parallelism, one should trace
messages between master and slaves (for any number of slaves).
This is the default, and it can be enabled on the command line with:
@example
  ./a.out --TOPC-trace=2 @var{args}
@end example
The variable @code{TOPC_OPT_trace} can be set in the code to
dynamically turn tracing on (1 or 2) and off (0) during a single run.
A trace value of 2 causes @samp{TOP-C} to invoke the application-defined
trace functions pointed to by
@code{TOPC_OPT_trace_input/result}.  If the application has not
defined trace functions, or if @code{TOPC_OPT_trace} is 1, then
the @samp{TOP-C} default trace functions are invoked.
All message traces
are displayed by the master at the time that the master sends or
receives the corresponding message.

@deftypevar  {void (*)(void *input)} TOPC_OPT_trace_input
@deftypevarx {void (*)(void *input, void *output)} TOPC_OPT_trace_result
@comment void (*TOPC_OPT_trace_action)(TOPC_ACTION action);
         Global pointer (default is @code{NULL}) to function returning
         @code{void}.  User can
         set it to his or her own trace function to print out
         data-specific tracing information in addition to generic
         message tracing of @code{TOPC_trace}.
@end deftypevar
@example
EXAMPLE:  if you pass integers via @code{TOPC_MSG()}, define
  @code{TOPC_trace_input()} as:
@group
         void mytrace_input( int *input ) @{
           printf("%d",*input);
         @}
         TOPC_OPT_trace_input = mytrace_input;
@end group
@end example

Note that the term @samp{result} in @code{TOPC_OPT_trace_result}
refers to an @samp{(input, output)} pair.

@node Stepping Through a Slave, Segmentation faults, Tracing Messages, Debugging and Tracing
@section Stepping Through a Slave Process with @samp{gdb}

@cindex --TOPC-slave-wait, debugging a slave process with @samp{gdb}

If you find the master hanging, waiting for a slave message, then the
probable cause is that @code{DoTask()} is doing something bad (hanging,
infinite loop, bus/segmentation error, etc.).  First try to isolate the
bug using a symbolic debugger (e.g. @samp{gdb}) and the sequential memory
model.  If your intended application is the shared memory model, you can also
use @samp{gdb} to set a breakpoint in your @samp{DoTask} routine
or at the @samp{TOP-C} invocation, @code{do_task_wrapper}.

If the bug only appears in the distributed memory model, you can still
symbolically debug @code{DoTask()} using @samp{gdb} (the GNU C debugger)
and its @code{attach} command
(@pxref{Running, , Attach, gdb, The GNU debugger}),
which allows you to attach and debug a separate running process.  This
lets you debug a running slave, if it is running o the same processor.
For this strategy, you will want the slave to delay executing to give
you time to execute gdb and attach on the remote host or remote thread.
The command line option @option{--TOPC-slave-wait=30} will force
the slave to wait 30 seconds before processing.

In applying this debugging strategy to an application @samp{./a.out},
one might see:
@example
  [ Execute ./a.out in one window for master process ]
  gdb ./a.out
  (gdb) run --TOPC-trace=1 --TOPC-safety=19 --TOPC-slave-wait=30 @var{args}

  [ In a second window for a slave process on a different host, now type: ]
  ps
    ...
    1492  p4 S    0:00 a.out @var{args} localhost 6262 -p4amslave
  gdb a.out
  ...
  (gdb) break do_task_wrapper
    Breakpoint 1 at 0x80492ab: file ...
    [ `break slave_loop' is also useful.  This calls do_task_wrapper ]
  (gdb) attach 1492
    Attaching to program `a.out', process 1492
    0x40075d88 in sigsuspend ()
  [ After 30 sec's, traced messages in master window appear, ]
  [ for slave, type: ]
  (gdb) continue
    Continuing.
    Breakpoint 1, DoTask (input=0x805dc50) at ...

  [ Continue stepping through master and slave processes in 2 windows ]
@end example

If you try to @dfn{attach} to a second slave process after attaching
to a first slave process, @samp{gdb} will offer to kill your first
slave process.  To avoid this situation, remember to execute @code{detach}
before attaching a second slave process.

@node Segmentation faults,  , Stepping Through a Slave, Debugging and Tracing
@section Segmentation faults and other memory problems

@cindex efence, debugging memory management
@cindex debugging memory management with efence
@cindex SIGSEGV, debugging with efence
@cindex segmentation fault, debugging with efence

Memory bugs are among the most difficult to debug.
If you suspect such a bug (perhaps because you are using @code{TOPC_MSG_PTR}),
and you fail to free previously malloc'ed memory, that is a memory leak.
If you access a buffer after freeing it, this may cause
a segmentation error at a later stage in the program.

If you suspect such a bug (and maybe you should if nothing else
worked), it is helpful to use a @emph{malloc or memory debugger}.
An excellent recent memory debugger is
@samp{valgrind}@footnote{@var{valgrind} is available at
@url{http://www.valgrind.kde.org}.}.
@samp{valgrind} can be directly applied to an application binary,
without recompilation or relinking.

An older debugger is @samp{efence},@footnote{@var{efence} is available at
@url{http://sources.isc.org/devel/memleak/efence}.}
@command{topcc}
provides direct support for @samp{efence}.
@samp{TOP-C} will link with the efence library if @code{--efence}
is passed to @command{topcc} or @command{topc++}.
@example
  topcc --efence ...
@end example
This causes all calls to @code{malloc} and @code{free} to
be intercepted by the @samp{efence} version.
Modify the line @code{LIBMALLOC=} in @command{topcc} or @command{topc++}
if you use a different library.

@node Performance and Long Jobs, Advanced Features, Debugging and Tracing, Top
@chapter Performance and Long Jobs

@menu
* Dropping Slow or Dead Slaves::  
* Strategies for Greater Concurrency::  
* Improving Performance::       
* Long Jobs::                   
@end menu

@node Dropping Slow or Dead Slaves,  Strategies for Greater Concurrency, Performance and Long Jobs, Performance and Long Jobs
@section Dropping Slow or Dead Slaves

When TOP-C recognizes a dead slave the master terminates communication with
that slave, and resubmits the task of that slave to a different slave.
(Currently, as of TOP-C 2.5.2, if a slave dies near the end of a computation
and after all tasks have been generated, TOP-C may fail to recognize
that slave.)

It is sometimes unclear whether a slave process is dead or slower than
others.  Even a slow slave process may hurt overall performance by
causing delays for other processes.
TOP-C internally declares a slave process to be "slow" if there are N
slaves, and if 3*N other tasks return after the given slave task is "due".
If a slow slave has not returned by @var{slave-timeout} seconds
(see @ref{Command Line Options}), then
the slave is considered dead.  The master process sends no further tasks
to that slave, and sends a replicate of the original task to a new
slave.

@node Strategies for Greater Concurrency, Improving Performance, Dropping Slow or Dead Slaves, Performance and Long Jobs
@section Strategies for Greater Concurrency

@table @asis
@item Strategy 1:  SEMI-INDEPENDENT TASKS:
    Define tasks so that most task outputs do not require any update.
    This is always the case for trivial parallelism (when tasks are
    independent of each other).  It is also often the case for many
    examples of search and enumeration problems.
@end table

@table @asis
@item Strategy 2:  CACHE PARTIAL RESULTS:
    Inside @code{DoTask()} and @code{UpdateSharedData()}, save partial
    computations in global private variables.  Then, in the event of a
    @code{REDO} action, @samp{TOP-C} guarantees to invoke
    @code{DoTask()} again on the
    original slave process or slave thread.  That slave may then use
    previously computed partial results in order to shorten the required
    computation.  Note that pointers on the slave to input and output
    buffers from previous @code{UPDATE} actions and from the original task
    input will no longer be valid.  The slave process must copy
    any data it wishes to cache to global variables.
    In the case of the shared memory model, those global variables must be
    thread-private.  (@pxref{Thread-Private Global Variables})
    Note the existence of @code{TOPC_is_REDO()} for testing for a @code{REDO}
    action.
@end table

@table @asis
@item Strategy 3:  MERGE TASK OUTPUTS:
    Inside @code{CheckTaskResult()}, the master may merge two or more task
    outputs in an application independent way.  This may avoid the
    need for a @code{REDO} action, or it may reduce the number of required
    @code{UPDATE} actions.
@end table

@node Improving Performance, Long Jobs, Strategies for Greater Concurrency, Performance and Long Jobs
@section Improving Performance

@cindex --TOPC-aggregated-tasks, usage
@cindex aggregation of tasks
@cindex network latency, overcoming it
@cindex finer grain parallelism

If your application runs too slowly due to excessive time for communication,
consider running multiple slave processes on a single processor.  This
allows one process to continue computing while another is communicating
or idle waiting for a new task to be generated by the master.

If communication overhead or idle time is still too high, consider if it is
possible to increase the granularity of your task.  TOP-C can
aggregating several consecutive tasks as a single larger
task to be performed by a single process.  This amortizes the network
latency of a single network message over several tasks.
For example, you can do combine 5 tasks
by invoking @option{--TOPC-aggregated-tasks=5} on
the command line of the application.  Alternatively, execute the statement:
@example
  TOPC_OPT_aggregated_tasks=5;
@end example
before @code{TOPC_master_slave()}.
In this situation, the five task outputs will also be bundled
as a single network message.  Currently (TOP-C 2.5.2), this
works only if all tasks return @code{NO_ACTION}.  TOP-C will signal
an error if @code{TOPC_OPT_aggregated_tasks} > 1 and any action
other than @code{NO_ACTION} is returned.

Other useful techniques that may improve performance of certain
applications are:
@enumerate
@item
  set up multiple slaves on each processor (if slave processors
        are sometimes idle)
@item
  re-write the code to bundle a set of tasks as a single task
        (to improve the granularity of your parallelism)
@end enumerate

@table @asis
@item PERFORMANCE ISSUE FOR MPI:
If you have a more efficient version of @samp{MPI} (perhaps a vendor version
tuned to your hardware), consider replacing @code{LIBMPI} in
@file{.../top-c/Makefile} by your vendor's @file{limbpi.a} or
@file{libmpi.so}, and delete or modify the the @code{LIBMPI} target in the
@file{Makefile}.
Alternatively, see the appendix,
@ref{Using a Different MPI with TOP-C},
for a more general way to use a different MPI dialect.
@end table
@table @asis
@item PERFORMANCE ISSUE FOR SMP (POSIX threads):
Finally under @samp{SMP}, there is an important performance issue
concerning the interaction of @samp{TOP-C} with the operating system.
First, the vendor-supplied compiler, @code{cc}, is recommended over
@code{gcc} for @samp{SMP}, due to specialized vendor-specific
architectural issues.  Second, if a thread completes its work before
using its full scheduling quantum, the operating system may yield the
CPU of that thread to another thread --- potentially including a thread
belonging to a different process.  There are several ways to defend
against this.  One defense is to insure that the time for a single task
is significantly longer than one quantum.  Another defense is to ask the
operating system to give you at least as many "run slots" as you have
threads (slaves plus master).  Some operating systems use
@code{pthread_setconcurrency()} to allow an application to declare this
information, and @samp{TOP-C} invokes @code{pthread_setconcurrency()}
where it is available.  However, other operating systems may have
alternative ways of tuning the scheduling of threads, and it is
worthwhile to read the relevant manuals of your operating system.
@end table

@node Long Jobs,  , Improving Performance, Performance and Long Jobs
@section Long Jobs and Courtesy to Others

@cindex --TOPC-slave-timeout, for long jobs and runaway jobs
@cindex SIGALRM, raised by @samp{TOP-C}

In the distributed memory model, infinite loops and broken socket
connections tend to leave orphaned processes running.
In the @samp{TOP-C} distributed memory model,
a slave times out if a task lasts longer than
a half hour or if  the master does not reply
in a half hour.
This is implemented with the UNIX system call, @code{alarm()}.

A half hour (1800 seconds) is the default timeout period.
The command line option @code{--TOPC-slave-timeout=@var{num}}
allows one to change this default.  If @var{num} is 0,
then there is no timeout and @samp{TOP-C} makes no calls
to @code{SIGALRM}.

The application writer may also find some of the following UNIX system calls
useful for allowing large jobs to coexist with other applications.
@table @asis
@item @code{ setpriority(PRIO_PROCESS,getpid(),@var{prio}) }
@code{#include <unistd.h>@*
#include <sys/resource.h>}@*
--- @var{prio} = 10 still
        gives you some CPU time.  @var{prio} = 19 means that any job of
        higher priority always runs before you.  Place in @code{main()}.
@item @code{ setrlimit(RLIMIT_RSS, &@var{rlp}) }
@code{#include <sys/resource.h>@*
struct rlimit rlp;@*
rlp.rlim_max = rlp.rlim_cur = @var{SIZE};}@*
--- @var{SIZE} is RAM limit (bytes).  If your system has
        significant paging, the system will prefer to keep your process
        from growing beyond SIZE bytes of resident RAM.  Even if you set
        nice to priority 20, this is still important.  Otherwise you may
        cause someone to page out much of his or her job in your favor during
        one of your infrequent quantum slices of CPU time.  Place in
        @code{main()}.  (Not all operating systems enforce this request.)
@end table

@node Advanced Features, TOP-C Raw Interface, Performance and Long Jobs, Top
@chapter Advanced Features of @samp{TOP-C}

It is best to postpone reading this section until the basic features
discussed in the previous chapters are clear.

@menu
* Testing for Task Continuations::  
* Aborting Tasks::              
* Allocation of Task Buffers::  
* Shared Memory Model::         
* Sequential Memory Model::     
* Caveats::                     
@end menu

@node Testing for Task Continuations, Aborting Tasks, Advanced Features, Advanced Features
@section Testing for Task Continuations and Redos

@cindex task continuation, testing
@cindex CONTINUATION, testing for
@cindex REDO, testing for

@deftypefun TOPC_BOOL TOPC_is_REDO ( void )
@deftypefunx TOPC_BOOL TOPC_is_CONTINUATION ( void )
    These return 0 (false) or 1 (true), according to whether the current
    call to @code{DoTask()} was a result of a @code{REDO}
    or @code{CONTINUATION()} action, respectively.  The result is
    is not meaningful if called outside of @code{DoTask()}.
@end deftypefun

@node Aborting Tasks, Allocation of Task Buffers, Testing for Task Continuations, Advanced Features
@section Aborting Tasks

@cindex aborting tasks

@deftypefun void TOPC_abort_tasks ( void )
@deftypefunx TOPC_BOOL TOPC_is_abort_pending ( void )
    @code{TOPC_abort_tasks()} should be called in @code{CheckTaskResult()}.
    @samp{TOP-C} then makes a best effort (no guarantee) to notify each
    slave.  TOP-C does not directly abort tasks.  However,
    @code{TOPC_is_abort_pending()} returns 1 (true)
    when invoked in @code{DoTask()} on a slave.  A typical
    @code{DoTask()} callback uses this to poll for an abort request
    from the master, upon which it returns early with a special
    task output.  At the beginning of the next new task, @code{REDO}
    or @code{CONTINUATION}, @samp{TOP-C} resets the pending abort
    to 0 (false).  See @file{examples/README} of the @samp{TOP-C}
    distribution for example code.
@end deftypefun

@node Allocation of Task Buffers, Shared Memory Model, Aborting Tasks, Advanced Features
@section Memory Allocation for Task Buffers

The principle of memory allocation in @samp{TOP-C} is that if an
application allocates memory, then it is the responsibility of the
application to free that memory.  This issue typically arises around the
issue of task buffers (@pxref{Task Buffers}) and calls
to @code{TOPC_MSG(@var{buf},@var{buf_size})}.  An application
often calls @code{@var{buf} = malloc(...);} or
@code{@var{buf} = new ...;} (in C++)
and copies data into that buffer before the call to @code{TOPC_MSG}.
Since the last action of @code{GenerateTaskInput()} or @code{DoTask()}
is typically to return @code{TOPC_MSG(@var{buf},@var{buf_size})},
there remains the question of how to free @var{buf}.

@menu
* Avoiding malloc::             
* Large Buffers and TOPC_MSG_PTR::  
* Allocation for TOPC_MSG_PTR::  
* Marshaling Complex Data Structures::  
@end menu

@node Avoiding malloc, Large Buffers and TOPC_MSG_PTR, Allocation of Task Buffers, Allocation of Task Buffers
@subsection Avoiding @code{malloc} and @code{new} with Task Buffers

The best memory allocation solution for task buffers is to implement the
buffers as local variables, and therefore on the stack.  This avoids the
need for @code{malloc} and @code{new}, and the question of how to later
free that memory.
If you use @code{TOPC_MSG} (as opposed to @code{TOPC_MSG_PTR}, 
@pxref{Large Buffers and TOPC_MSG_PTR}), then recall that @code{TOPC_MSG}
copies its buffer to a separate @code{TOP-C} space.  For example,
@example
@{ int x;
   ...
  return TOPC_MSG(&x, size_of(x));
@}
@end example

@cindex variable size task buffers
@cindex task input/output buffers, variable size

If your task buffer is of fixed size, one can allocate it as a character
array on the stack:  @code{char buf[BUF_SIZE];}.
If your buffer contains variable size data, consider using
@code{alloca} in place of @code{malloc} to allocate on the
stack.
@example
@{ ...
  buf = alloca(buf_size);
  return TOPC_MSG(buf, buf_size);
@}
@end example

In all of the above cases, there is no need to free the buffer, since
@code{TOPC_MSG} will make a @samp{TOP-C}-private copy and the
stack-allocated buffer will disappear when the current routine exits.
Note that @code{alloca} may be unavailable on your system.
Alternatively, the use of @code{alloca} may be undesirable due to very
large buffers and O/S limits on stack size.  In such cases, consider the
following alternative.
@example
@{ TOPC_BUF tmp;
  ...
  buf = malloc(buf_size);
  tmp = TOPC_MSG(buf, buf_size);
  free(buf);
  return tmp;
@}
@end example

@node Large Buffers and TOPC_MSG_PTR, Allocation for TOPC_MSG_PTR, Avoiding malloc, Allocation of Task Buffers
@subsection Using @code{TOPC_MSG_PTR()} to Avoid Copying Large Buffers

@cindex TOPC_MSG_PTR()
@cindex large message buffers

If the cost of copying a large buffer is a concern, @samp{TOP-C} provides
an alternative function, which avoids copying into @samp{TOP-C} space.

@deftypefun TOPC_BUF TOPC_MSG_PTR ( void *@var{buf}, int @var{buf_size} )
	Same as @code{TOPC_MSG()}, except that it does not copy
	@var{buf} into @samp{TOP-C} space.  It is the responsibility
	of the application not to free or modify @var{buf} as long
	as @samp{TOP-C} might potentially pass it to an
	application callback function.
@end deftypefun

@code{TOPC_MSG_PTR()} is inherently dangerous, if the application
modifies or frees a buffer and @samp{TOP-C} later passes that buffer
to a callback function.  It may be useful when the cost of copying
large buffers is an issue, or if one is concerned about @samp{TOP-C}
making a call to @code{malloc()}.  Note that the invocation
@example
  ./a.out --TOPC-safety=4
@end example
@noindent
automatically converts all calls to @code{TOPC_MSG_PTR()} into
calls to @code{TOPC_MSG()}.  This is useful in deciding
if a bug is related to the use of @code{TOPC_MSG_PTR()}.

An application should not pass a buffer on the stack to @code{TOPC_MSG_PTR()}.
This can be avoided either by declaring a local variable to be
@samp{static}, or else using a global variable (or a class member
in the case of C++).  In such cases, it is the responsibility of the
application to dynamically create and free buffers.
An example of how this can be done follows in the next section.

Note that if the application code must also be compatible with the
shared memory model, then the static local variable or global variable
must also be @dfn{thread-private}
(@ref{Thread-Private Global Variables}).

For examples of coding with @code{TOPC_MSG_PTR()} that are compatible
with all memory models, including the shared memory model,
see @file{examples/README} and the corresponding examples
in the @samp{TOP-C} distribution.

@node Allocation for TOPC_MSG_PTR, Marshaling Complex Data Structures, Large Buffers and TOPC_MSG_PTR, Allocation of Task Buffers
@subsection Allocation and Freeing of Task Buffers for @code{TOPC_MSG_PTR()}

Recall the syntax for creating a message buffer of type @code{TOPC_BUF}
using
@code{TOPC_MSG_PTR(@var{buf}, @var{buf_size})}.  The two callback functions
@code{GenerateTaskInput()} and @code{DoTask()} both return such a
message buffer.  In the case of
@code{GenerateTaskInput()}, @samp{TOP-C} saves a copy of the buffer,
which becomes an input argument to @code{CheckTaskResult()}
and to @code{UpdateSharedData} on the master.
Hence, if @var{buf} points to a temporarily allocated buffer,
it is the responsibility of the @samp{TOP-C} callback function to free the
buffer only @emph{after} the callback function has returned.
This seeming contradiction can be easily handled by the following code.
@sp 1
@example
    TOPC_BUF GenerateTaskInput() @{
      static void *buf = NULL;
      if ( buf == NULL ) @{ malloc(buf_size); @}
      ... [ Add new message data to buf ] ...
      return TOPC_MSG_PTR(buf, buf_size);
    @}
@end example
@sp 1
If @code{buf_size} might vary dynamically between calls, the following
fragment solves the same problem.
@example
    TOPC_BUF GenerateTaskInput() @{
      static void *buf = NULL;
      if ( buf != NULL ) @{ free(buf); @}
      ... [ Compute buf_size for new message ] ...
      buf = malloc( buf_size );
      ... [ Add new message data to buf ] ...
      return TOPC_MSG_PTR(buf, buf_size);
    @}
@end example

Note that @code{buf}@ is allocated as a @emph{static} local
variable.  @samp{TOP-C} restricts the @var{buf} of 
@code{TOPC_MSG_PTR(@var{buf}, @var{buf_size})} to point to a buffer that is in
the heap (not on the stack).  Hence, @var{buf} must @emph{not} point to
non-static local data.

@comment TEXT FOR REUSE HERE OR ELSEWHERE:
@ignore

@comment @node Modifying Task Buffers, Local Shared Data, Allocation for TOPC_MSG_PTR, Allocation of Task Buffers
@comment @subsection Modifying Task Buffers in @code{CheckTaskResult()}

When a @samp{TOP-C} callback function is passed a
@dfn{task input} or @dfn{task output}, that buffer is a pointer
into @samp{TOP-C} space.  (As an exception, if the shared memory model
is used with @code{TOPC_MSG_PTR()}, then the buffer will point into
the application memory space.)  The callback function may freely
use or even modify the data in the buffer, but the buffer
pointer will no longer be valid after the callback function returns.
If a later invocation of a callback function wishes to use the data
in the buffer, the @samp{TOP-C} application must cache a private
copy and point to it with a global variable (or with a @dfn{thread-private
global variable} (@pxref{Thread-Private Global Variables}) if the application
is also to work with the shared memory model).

@comment @node Local Shared Data, Marshaling Complex Data Structures, Allocation for TOPC_MSG_PTR, Allocation of Task Buffers
@comment @subsection Local Shared Data

Sometimes your shared data may be on the stack, instead of in a global
variable.  
In order to make this local data accessible to a @samp{TOP-C} callback
function, such as @code{UpdateSharedData()}, you will need to create a global
variable pointing to your local shared data.  The example below makes
the local shared data in the array @code{data[]} in the function
@code{foo()} available to the callback function
@code{UpdateSharedData()}.

@example
  int *global_copy_of_data;
  void UpdateSharedData( int *input, void *output) @{
    global_copy_of_data[*input] = output;
  @}
  int foo() @{
    int data[SIZE];
    global_copy_of_data = data;
    TOPC_master_slave(...);
  @}
@end example

Of course, @samp{C++} provides a more natural way to handle this by
placing @code{global_copy_of_data}, @code{foo} and
@code{UpdateSharedData} in a single class.

@end ignore

@node Marshaling Complex Data Structures,  , Allocation for TOPC_MSG_PTR, Allocation of Task Buffers
@subsection Marshaling Complex Data Structures into @samp{TOP-C} Task Buffers

If you use a distributed memory model and the buffer pointed to by
@code{input} includes fields with their own pointers, the application
must first follow all pointers and copy into a new buffer all data
referenced directly or indirectly by @code{input}.  The new buffer can
then be passed to @code{TOPC_MSG()}.  This copying process is called
@dfn{marshaling}.  @xref{Task Buffers, ,
Marshaling and Heterogeneous Architectures}.

If following all pointers is a burden, then one can
load the application on the master and slaves at a common absolute
address, and insure that all pointer references have been initialized
before the first call to @code{TOPC_master_slave()}.  In @samp{gcc},
one specifies an absolute load address with code such as:
@example
  gcc -Wl,-Tdata -Wl,-T@var{hex_addr} ...
@end example
These flags are for the data segment.  If the pointers indirectly
reference
data on the stack, you may have to similarly specify stack absolute addresses.
Choosing a good @var{hex_addr} for all machines may be a matter of trial
and error.  In a test run, print out the absolute addresses of some
pointer variables near the beginning of your data memory.

Specifying an absolute load address has many risks, such as if
the master and slaves use different versions of the operating system,
the compiler, other software, or different hardware configurations.
Hence, this technique is recommended only as a last resort.

@ignore
@comment @node Experimental Version,  , Caveats, Miscellaneous Issues
@comment @subsection Notes on Experimental Version
@example

/* EXPERIMENTAL:  not currently supported */
request_recv_buf(int buf_size) - useful only for distributed memory.
   Ask @samp{TOP-C} and socket interface for larger buffer for large messages.
@end example

There are also situations in which one wishes to add new slaves during
a currently running session (for advanced users, only).  This is made
possible for homogeneous architectures by invoking the loader.
This was written jointly by Gene Cooperman and Victor Grinberg.

The @file{.../top-c/loader/config.h} file should be modified with the network
address of the running job:  @var{MASTERNAME} and @var{MASTERPORT}
(and currently change them in C files or use command line args)
Other options can be left as default.   One then recompiles:
@example
    (cd .../top-c/loader; make; cd .../top-c; make @var{APPLICATION})
@end example
For an example @var{APPLICATION} type:  @code{make parfactor-loader}

Finally, one runs the application:
@example
    ./a.out -masterport @var{PORTNUMBER}
@end example
and on a remote processor of the same architecture, one can
download the binary, @file{.../top-c/loader}, and execute:
@example
    ./loader -p @var{PORTNUMBER}
@end example
The loader application will continue to run until killed, so that the
machine will continue to act as a CPU server for further jobs.

@var{PORTNUMBER} will default to @var{MASTERPORT}.  The provision for
adding @var{PORTNUMBER} to the command line is provided only in case the
default port is in use.

@end ignore

@node Shared Memory Model, Sequential Memory Model, Allocation of Task Buffers, Advanced Features
@section Optimizing TOP-C Code for the Shared Memory Model

@cindex memory model, shared
@cindex shared memory model

      The @samp{TOP-C} programmer's model changes slightly for shared
memory.  With careful design, one can use the same application source
code both for distributed memory and shared memory architectures.
Processes are replaced by threads.  @code{UpdateSharedData()} is
executed only by the master thread, and not by any slave thread.  As
with distributed memory, @code{TOPC_MSG()} buffers are copied to
@samp{TOP-C} space (shallow copy).  As usual, the application is responsible
for freeing any application buffers outside of @samp{TOP-C} space.
Furthermore, since the master and slaves share memory, @samp{TOP-C}
creates the slaves only during the first call to master_slave.  If a
slave needs to initialize any private data (see
@code{TOPC_thread_private}, below), then this can be done by the slave
the first time that it gains control through @code{DoTask()}.

Two issues arise in porting a distributed memory
@samp{TOP-C} application to shared memory.
@enumerate
@item
  reader-write synchronization:  @code{DoTask()} must not read
  shared data while @code{UpdateSharedData()} (on the master)
  simultaneously writes to the shared data.
@item
  creating thread-private (unshared) global variables:
@end enumerate

Most @samp{TOP-C} applications for the distributed memory model will run
unchanged in the shared memory model.  In some cases, one must add
additional @samp{TOP-C} code to handle these additional issues.  In all
cases, one can easily retain compatibility with the distributed memory model.

@menu
* Reader-Writer Synchronization::  
* Thread-Private Global Variables::  
* Volatile Variables::          
* SMP Performance::             
@end menu

@node Reader-Writer Synchronization, Thread-Private Global Variables, Shared Memory Model, Shared Memory Model
@subsection Reader-Writer Synchronization

@cindex synchronization of threads, shared memory model
@cindex threads, synchronization in shared memory model
@cindex reader-writer synchronization
@cindex fine grain thread parallelism

In shared memory, @samp{TOP-C} uses a classical single-writer,
multiple-reader strategy with writer-preferred for lock requests.
By default, @code{DoTask()} acts as the critical section of the
readers (the slave threads) and @code{UpdateSharedData()} acts as the
critical section of the writer (the master thread).
@samp{TOP-C} sets a read lock around all of DoTask() and a write
lock around all of UpdateSharedData().

As always in the @samp{TOP-C} model,
it is an error if an application writes to shared data outside
of @code{UpdateSharedData()}.  Note that @code{GenerateTaskInput()}
and @code{CheckTaskResult()} can safely read the shared data without
a lock in this case, since these routines and @code{UpdateSharedData()}
are all invoked only by the master thread.

The default behavior implies that @code{DoTask()} and
@code{UpdateSharedData()} never run simultaneously.  Optionally, one
can achieve greater concurrency through a finer level of granularity
by declaring to @samp{TOP-C} which sections of code read or write
shared data.  If @samp{TOP-C} detects any call to @code{TOPC_ATOMIC_READ(0)},
@samp{TOP-C} will follow the critical sections declared by the
application inside of @code{DoTask()} and @code{UpdateSharedData()}.

@deftypefun void TOPC_ATOMIC_READ ( 0 ) @{ @var{... C code ...} @}
@deftypefunx void TOPC_ATOMIC_WRITE ( 0 ) @{ @var{... C code ...} @}
  This sets a global read or write lock in effect during the time
  that @var{C code} is being executed.  If a thread holds a write lock,
  no thread may hold a read lock.  If no thread holds a write lock,
  arbitrarily many threads hold a read lock.  If a thread requests
  a write lock, no additional read locks will be granted until after the
  write lock has been granted.  See @file{examples/README} of the
  @samp{TOP-C} distribution for example code.
@end deftypefun

It is not useful to use @code{TOPC_ATOMIC_READ()} outside of @code{DoTask()}
not to use @code{TOPC_ATOMIC_WRITE()} outside of @code{UpdateSharedData()}.

The number 0 refers to page 0 of shared data.  @samp{TOP-C} currently
supports only a single common page of shared data, but future versions
will support multiple pages.  In the future, two threads will be able to
simultaneously hold write locks if they are for different pages.

The following alternatives to @code{TOPC_ATOMIC_READ()}
and @code{TOPC_ATOMIC_WRITE()} are provided for greater flexibility.

@deftypefun void TOPC_BEGIN_ATOMIC_READ ( 0 )
@deftypefunx void TOPC_END_ATOMIC_READ ( 0 )
@deftypefunx void TOPC_BEGIN_ATOMIC_WRITE ( 0 )
@deftypefunx void TOPC_END_ATOMIC_WRITE ( 0 )
  The usage is the same as for @code{TOPC_ATOMIC_READ}
and @code{TOPC_ATOMIC_WRITE}.
@end deftypefun

In the distributed memory model of @samp{TOP-C}, all of the
above invocations for atomic reading and writing are ignored,
thus retaining full compatibility between the shared and
distributed memory models.

@node Thread-Private Global Variables, Volatile Variables, Reader-Writer Synchronization, Shared Memory Model
@subsection Thread-Private Global Variables

@cindex thread-private variable
@cindex global thread-private variable
@cindex static local variables and threads
@cindex @samp{THREAD_PRIVATE}

A @dfn{thread-private} variable is a variable whose data is not
shared among threads: i.e., each thread has a private copy of
the variable.
The only variables that are thread-private by default in
shared memory are those on the stack (non-static, local variables).  All
other variables exist as a single copy, shared by all threads.
This is inherent in the POSIX standard for threads in C/C++.
If @code{DoTask()} accesses any global variables or local static variables,
then those variables must be made thread-private.

Ideally, if C allowed it, we would just write something like:
@example
  THREAD_PRIVATE int myvar = 0;  /* NOT SUPPORTED */
@end example
Instead, @samp{TOP-C} achieves the same effect @samp{as if} it had
declared
@example
  TOPC_thread_private_t TOPC_thread_private;
@end example
This allows the application writer to include in his or her code:
@example
  typedef int TOPC_thread_private_t;
  #define myvar TOPC_thread_private;
  int myvar_debug() @{return myvar;@} /* needed to access myvar in gdb */
@end example

@samp{TOP-C} provides primitives to declare a single thread-private
global variable.  @samp{TOP-C} allows
the application programmer to declare the type of that variable.
@defvar TOPC_thread_private
        A pre-defined thread-private variable of type,
        @code{TOPC_thread_private_t}.  It may be
        used like any C variable, and each thread has its own private
        copy that will @emph{not} be shared.
@end defvar
@defvr Type TOPC_thread_private_t
        Initially, undefined.  User must define this type using @code{typedef}
        if @code{TOPC_thread_private} is used.
@end defvr

If more than one thread-private variable is desired, define
@code{TOPC_thread_private_t} as a @var{struct}, and use each
field as a separate thread-private variable.

@noindent
EXAMPLE:

@example
/* Ideally, if C allowed it, we would just write:
 *      THREAD_PRIVATE struct @{int my_rank; int rnd;@} mystruct;
 * We emulate this using TOP-C's implicitly declared thread-private var:
 *      TOPC_thread_private_t TOPC_thread_private;
 */
typedef struct @{int my_rank; int rnd;@} TOPC_thread_private_t;
#define mystruct TOPC_thread_private
void set_info() @{
  mystruct.my_rank = TOPC_rank();
  mystruct.rnd = rand();
@}
void get_info() @{
foo();
  if (mystruct.my_rank != TOPC_rank()) printf("ERROR\n");
  printf("Slave %d random num:  %d\n", mystruct.my_rank, mystruct.rnd);
@}
TOPC_BUF do_Task() @{
  set_info(); /* info in mystruct is NOT shared among threads */
  get_info();
  ...;
@}
@end example

Additional examples can be found by reading
@file{examples/README} in the @samp{TOP-C} distribution.

@node Volatile Variables, SMP Performance, Thread-Private Global Variables, Shared Memory Model
@subsection Sharing Variables between Master and Slave and Volatile Variables

@cindex volatile C/C++ variables

The shared memory model, like any @samp{SMP} code,
allows the master and slaves to
communicate through global variables, which are shared by default.
It is recommended not to use this feature, and instead to maintain
communication through @code{TOPC_MSG()}, for ease of code maintenance,
and to maintain portability with the other @samp{TOP-C} models
(distributed memory and sequential).  If you do use your own global shared
variables between master and slaves, be sure to declare them @code{volatile}.
@example
  volatile int myvar;
@end example
ANSI C requires this qualifier if a variable
may be accessed or modified by more than one thread.
Without this qualifier, your program may not run correctly.

To be more precise, if a non-local variable is accessed more than once
in a procedure, the compiler is allowed to keep the first access value
in a thread register and reuse it at later occurrences, without consulting
the shared memory.  A volatile declaration tells the compiler to re-read
the value from shared memory at each occurrence.  Similarly, a write to
a volatile variable causes the corresponding transfer of its value from
a register to shared memory to occur at a time not much later than the
execution of the write instruction.

If you suspect a missing volatile declaration, note that @samp{gcc}
support the following command-line options.
@example
@group
  gcc -fvolatile -fvolatile-global ...
  # If topcc uses gcc:
  topcc --pthread -fvolatile -fvolatile-global myfile.c
@end group
@end example
The option @code{-fvolatile} tells @samp{gcc} to compile all memory
references through pointers as volatile, and the option
@code{-fvolatile-global} tells @samp{gcc} to compile all memory
references to extern and global data as volatile.
However, note that this implies a performance penalty
since the compiler will issue
a load/store instruction for each volatile access, and
will @emph{not} keep volatile values in registers.


@node SMP Performance,  , Volatile Variables, Shared Memory Model
@subsection SMP Performance

Note that @samp{SMP} involves certain performance issues that do not arise
in other modes.  If you find a lack of performance, please read
@ref{Improving Performance}.  Also, note that the vendor-supplied
compiler, @code{cc}, is often recommended over @code{gcc} for
@samp{SMP}, due to specialized vendor-specific architectural issues.

@node Sequential Memory Model, Caveats, Shared Memory Model, Advanced Features
@section Modifying TOP-C Code for the Sequential Memory Model

@cindex memory model, sequential
@cindex sequential memory model

@samp{TOP-C} also provides a sequential memory model.  That model is
useful for first debugging an application in a sequential context, and
then re-compiling it with one of the parallel @samp{TOP-C} libraries for
production use.  The application code for the sequential library is
usually both source and object compatible with the application code for
a parallel library.  The sequential library emulates an application with
a single @samp{TOP-C} library.

The sequential memory model emulates an application in which
@samp{DoTask()} is executed in the context of the single slave
process/thread, and all other code is executed in the context of the
master process/thread.  This affects the values returned by
@code{TOPC_is_master()} and @code{TOPC_rank()}.  In particular,
conditional code for execution on the master will work
correctly in the sequential memory model, but the following conditional
code for execution on the slave will probably @emph{not} work correctly.
@example
int main( int argc, char *argv[] ) @{
  TOPC_init( &argc, &argv );
  if ( TOPC_is_master() )
    ...;  /* is executed in sequential model */
  else
    ...;  /* is @emph{never} executed in sequential model */
  TOPC_master_slave( ..., ..., ..., ...);
  TOPC_finalize();
@}
@end example

@node Caveats,  , Sequential Memory Model, Advanced Features
@section Caveats
IMPORTANT:
@samp{TOP-C} sets @code{alarm()} before waiting to receive
  message from master.  By default, if the master does not reply in a
  half hour (1800 seconds), then the slave receives
  @code{SIGALRM} and dies.
  This is to prevent runaway processes in dist. memory version when master dies
  without killing all slaves.  @ref{Long Jobs},
  in order to change this default.
  If your applications also uses @code{SIGALRM}, then run your
  application with @code{--TOPC-slave-timeout=0} and @samp{TOP-C}
  will not use @code{SIGALRM}.

@code{GenerateTaskInput()} and @code{DoTask()}
  This memory is managed by @samp{TOP-C}.

The slave process attempts to set current directory to the same as the master
  inside @code{TOPC_init()} and produces a warning if unsuccessful.

When a task buffer is copied into @samp{TOP-C} space,
it becomes word-aligned.  If the buffer was originally not
word-aligned, but some field in the buffer was word-aligned,
the internal field will no longer be word-aligned.  On some
architectures, casting a non-word-aligned field to @samp{int}
or certain other types will cause a bus error.

@node TOP-C Raw Interface, Acknowledgements, Advanced Features, Top
@chapter @samp{TOP-C} Raw Interface for Parallelizing Sequential Code

There are instances when tasks are most naturally generated deep
inside nested loops.  Often, this occurs in parallelizing existing
sequential applications.
In such circumstances, it may be difficult to
re-write the code to create a function @code{GenerateTaskInput()}, since
that would require turning the loops inside out.  (If you don't know what this
refers to, then you probably don't need the raw interface.)

On a first reading, you may wish to first look at the example for
either a @samp{for} loop or @samp{while} loop, depending on the type of
loop that you are parallelizing.  Then return to the formal
descriptions of the @samp{TOP-C} raw functions.  This chapter assumes
familiarity with the basic concepts of @ref{Overview} and @ref{Writing
TOP-C Applications}.

@menu
* TOPC-C raw functions::        
* Parallelizing For Loops::     
* Parallelizing While Loops::   
@end menu

@node TOPC-C raw functions, Parallelizing For Loops, TOP-C Raw Interface, TOP-C Raw Interface
@section @samp{TOP-C} raw functions

@deftypefun void TOPC_raw_begin_master_slave
          (@var{do_task}, @var{check_task_result}, @var{update_shared_data})
@deftypefunx void TOPC_raw_end_master_slave ()
        This behaves like master_slave, with
        @code{TOPC_raw_submit_task_input(@var{input})} serving
        the role of @code{GenerateTaskInput()}.  The slave blocks inside
        @code{TOPC_raw_begin_master_slave()} and executes @samp{do_task()} and
        @samp{update_shared_data()} until the master executes
        @code{TOPC_raw_end_master_slave()}.  At that time, the slave
        unblocks.  The slave does nothing inside
        @code{TOPC_raw_end_master_slave()}.
@end deftypefun

@deftypefun void TOPC_raw_submit_task_input ( TOPC_BUF @var{input} )
        Invoked by master between @code{TOPC_raw_begin_master_slave()}
        and @code{TOPC_raw_end_master_slave()};  Typical usage is:
@example
@group
     @code{TOPC_raw_submit_task_input(TOPC_MSG(&@var{input_data},
                                         sizeof(@var{input_data})) );}
@end group
@end example
        The argument, @var{input}, corresponds to what would be returned by
        @code{GenerateTaskInput()} in the routine @code{TOPC_master_slave()}.
        @var{input} will be processed by @code{DoTask()} and its siblings,
        just as in @code{TOPC_master_slave()}).
        There can be multiple occurrences of
        @code{TOPC_raw_submit_task_input()}.
@end deftypefun

@deftypefun TOPC_BOOL TOPC_raw_wait_for_task_result ()
        Invoked by master between @code{TOPC_raw_begin_master_slave()} and
        @code{TOPC_raw_end_master_slave()};
        If no tasks are outstanding, returns false immediately.  Otherwise, it
        blocks until a task does return.  It calls application
	callback, @code{CheckTaskResult()}, and then returns true.
@end deftypefun

@node Parallelizing For Loops, Parallelizing While Loops, TOPC-C raw functions, TOP-C Raw Interface
@section Parallelizing @samp{for} Loops

Assume that we are parallelizing a code fragment of the following form.
The variables @code{i} and @code{j} will be the input to
@code{DoTask()}, and any data structures indexed by @code{i} and
@code{j} (for example @code{array} in @code{array[i][j]}) will be
part of the shared data.
@example
  float array[ROWS][COLS];
  ...
    for ( i = 0; i < 10; i++ ) @{
      for ( j = 0; j < 10; j++ ) @{
        /* do_task: */ ...
        /* update:  */ array[i][j] = ...;
      @}
    @}
@end example

Assume that the labels @code{do_task} and @code{update} above
correspond to the callback functions @code{DoTask()} and
@code{UpdateSharedData()}.  Then the code is parallelized below.

@example
  float array[ROWS][COLS];
  typedef struct @{int i_val; int j_val;@} input_t;
  void *DoTask(input_t *buf) @{
    int i = (*buf).i_val, j = (*buf).j_val;
    /* do_task: */ ...
  @}
  void *CheckTaskResult(input_t *buf, output_t *buf2) @{
    /* update:  */ array[i][j] = ...;
    return NO_ACTION;
  @}
  main(int argc, char **argv) @{
    TOPC_init( &argc, &argv );
    TOPC_raw_begin_master_slave(DoTask, CheckTaskResult,
                                UpdateSharedData);
    if (TOPC_is_master()) @{
      for ( i = 0; i < 10; i++ ) @{
        for ( j = 0; j < 10; j++ ) @{
          input_t input;
          input.i_val = i; input.j_val = j;
          TOPC_raw_submit_task_input( TOPC_MSG(&input, sizeof(input)) );
        @}
      @}
    @} TOPC_raw_end_master_slave();
    TOPC_finalize();
  @}
@end example

@node Parallelizing While Loops,  , Parallelizing For Loops, TOP-C Raw Interface
@section Parallelizing @samp{while} Loops

Assume that we are parallelizing a code fragment of the following form
and @code{input} is a pointer.
@example
  while ( (input = next_input()) != NULL ) @{
    /* do_task: */ ...
    /* update:  */ ...
  @}
@end example

Assume that the labels @code{do_task} and @code{update} above
correspond to the callback functions @code{DoTask()} and
@code{UpdateSharedData()}.  Then the code is parallelized below,
where @code{input_size} must be specified by the application before it
is used.

@example
  TOPC_init( &argc, &argv );
  TOPC_raw_begin_master_slave(DoTask, CheckTaskResult,
                              UpdateSharedData);
  if (TOPC_is_master()) @{
    while ( (input = next_input()) != NULL
            || TOPC_raw_wait_for_task_result() ) @{
      TOPC_raw_submit_task_input( TOPC_MSG(input, input_size) );
    @}
  @} TOPC_raw_end_master_slave();
  TOPC_finalize();
@end example

Note that the code inside the @dfn{raw begin/end block} is executed
only by the master in the code above.

@comment THIS COMMENT SHOULD PROBABLY BE REMOVED.
@comment Hence, any shared data between master and slave
@comment must be declared outside of the @dfn{raw begin/end block}.
@comment @xref{Local Shared Data}, for a relevant example.

If the buffer, @code{input}, contains pointers to other data, then you
will need to @dfn{marshal} the data before calling @code{TOPC_MSG()}.
@xref{Task Buffers, , Marshaling and Heterogeneous Architectures}.

@node Acknowledgements, Summary, TOP-C Raw Interface, Top
@chapter Acknowledgements

A project of this scope cannot be achieved alone.  While Gene Cooperman
was the primary author, the project has benefited from contributions
by several various individuals and institutions at different times.

The author wishes to thank the National Science Foundation for
support under which much of this work was developed.
The author wishes to thank the Mariner Project at Boston University
for the use of the Origin 2000 and other facilities which helped in the
development of this software.  An earlier, experimental version of mpinu
(MPI subset) was written by Markos Kyzas and partially revised by Gene
Cooperman.  Michael Weller provided ideas for improving some of the C
code, and provided valuable feedback when he adapted the @samp{TOP-C} ideas
to a large application on an IBM SP-2.  The loader module is joint
with Victor Grinberg.  Further experience and feedback was gained
from the GAP community when the @samp{TOP-C} model was ported to ParGAP, a
refereed share package.  (GAP -- Groups, Algorithms and Programming)
is a language similar to Maple, specialized for symbolic computations
in computational algebra and especially computational group theory.)
@samp{TOP-C}, version 2, was exported by Victor Grinberg from ParGAP, with
enhancements by Gene Cooperman.  Some important feedback was gained
in the TOP-C parallelization of Geant4.
(Geant4 is a toolkit for the Monte Carlo simulation of particle-matter
interaction.  The package has close to a million lines of C++ code.
The TOP-C parallelization is included with the Geant4 distribution.)
Xiaoqin Ma analyzed mechanisms for
detecting and recovering from dead slaves, broken sockets, etc.,
and wrote the first version of code to handle that.

@page

@node Summary, Example, Acknowledgements, Top
@appendix Summary of @samp{TOP-C} Commands
@comment To generate this appendix, do:  grep '@def\|@end def' topc.texi
@comment   and then re-format.

@noindent
@emph{From @ref{The Main TOP-C Library Calls}.}
@table @code
@need 400
@item void TOPC_init ( int *@var{argc}, char ***@var{argv} )
@itemx void TOPC_finalize ( void )
@flushright
  Function
@end flushright
@need 1800
@item void TOPC_master_slave
  ( TOPC_BUF (*@var{generate_task_input})(),@*@ @
    TOPC_BUF (*@var{do_task})(void *input),@*@ @
    TOPC_ACTION (*@var{check_task_result})(void *input, void *output),@*@ @
    void (*@var{update_shared_data})(void *input, void *output)
  @*)
@flushright
  Function
@end flushright
@need 400
@item TOPC_BUF TOPC_MSG ( void *@var{buf}, int @var{buf_size} )
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Callback Functions,
       Callback Functions for @code{TOPC_master_slave()},
       Callback Functions for @code{TOPC_master_slave()} }.}
@table @code
@need 400
@item TOPC_BUF GenerateTaskInput ( void )
@flushright
  Function
@end flushright
@need 400
@item TOPC_BUF DoTask ( void *@var{input} )
@flushright
  Function
@end flushright
@need 400
@item TOPC_ACTION CheckTaskResult ( void *@var{input}, void *@var{output})
@flushright
  Function
@end flushright
@need 400
@item void UpdateSharedData ( void *@var{input}, void *@var{output} )
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Actions,
       Actions Returned by @code{CheckTaskResult()},
       Actions Returned by @code{CheckTaskResult()} }.}
@table @code
@need 400
@item Action TOPC_ACTION NO_ACTION
@flushright
  Action
@end flushright
@need 400
@item Action TOPC_ACTION UPDATE
@flushright
  Action
@end flushright
@need 400
@item Action TOPC_ACTION REDO
@flushright
  Action
@end flushright
@need 400
@item Action TOPC_ACTION CONTINUATION ( void *@var{next_input} )
@flushright
  Action
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{TOP-C Utilities}.}
@table @code
@need 400
@item TOPC_BOOL TOPC_is_up_to_date ( void )
@flushright
  Function
@end flushright
@need 400
@item int TOPC_rank ( void )
@flushright
  Function
@end flushright
@need 400
@item TOPC_BOOL TOPC_is_master ( void )
@flushright
  Function
@end flushright
@need 400
@item int TOPC_num_slaves ( void )
@flushright
  Function
@end flushright
@need 400
@item int TOPC_num_idle_slaves ( void )
@flushright
  Function
@end flushright
@need 400
@item int TOPC_node_count ( void )
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Shared Memory Model,
       Optimizing TOP-C Code for the Shared Memory Model,
       Optimizing TOP-C Code for the Shared Memory Model }.}
@table @code
@need 400
@item TOPC_thread_private
@flushright
  Variable
@end flushright
@need 400
@item TOPC_thread_private_t
@flushright
  Type
@end flushright
@need 400
@item void TOPC_ATOMIC_READ ( 0 ) @{ @var{... C code ...} @}
@itemx void TOPC_ATOMIC_WRITE ( 0 ) @{ @var{... C code ...} @}
@flushright
  Function
@end flushright
@need 400
@item void TOPC_BEGIN_ATOMIC_READ ( 0 )
@itemx void TOPC_END_ATOMIC_READ ( 0 )
@itemx void TOPC_BEGIN_ATOMIC_WRITE ( 0 )
@itemx void TOPC_END_ATOMIC_WRITE ( 0 )
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{TOP-C Raw Interface,
       Raw @samp{TOP-C} interface:  @code{raw_master_slave},
       Raw @samp{TOP-C} interface:  @code{raw_master_slave} }.}
@table @code
@need 800
@item void TOPC_raw_begin_master_slave
          (@var{do_task}, @var{check_task_result}, @var{update_shared_data})
@itemx void TOPC_raw_end_master_slave ()
@flushright
  Function
@end flushright
@need 400
@item void TOPC_raw_submit_task_input ( TOPC_BUF @var{input} )
@flushright
  Function
@end flushright
@need 400
@item TOPC_BOOL TOPC_raw_wait_for_task_result ()
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Aborting Tasks}.}
@table @code
@item void TOPC_abort_tasks ( void )
@itemx TOPC_BOOL TOPC_is_abort_pending ( void )
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Testing for Task Continuations}.}
@table @code
@item TOPC_BOOL TOPC_is_REDO ( void )
@itemx TOPC_BOOL TOPC_is_CONTINUATION ( void )
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Large Buffers and TOPC_MSG_PTR}.}
@table @code
@item TOPC_BUF TOPC_MSG_PTR ( void *@var{buf}, int @var{buf_size} )
@flushright
  Function
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Command Line Options,
       Command Line Options in TOP-C Applications,
       Command Line Options in TOP-C Applications }.}
@table @code
@item --TOPC-help@samp{[=<0/1>]}
@flushright
  [boolean, default: false]
@end flushright
@item --TOPC-verbose@samp{[=<0/1>]}
@flushright
  [boolean, default: false]
@end flushright
@item --TOPC-stats@samp{[=<0/1>]}
@flushright
  [boolean, default: false]
@end flushright
@item --TOPC-num-slaves@samp{=<int>}
@flushright
  [default: -1 (system-defined)]
@end flushright
@item --TOPC-slave-wait@samp{=<int>}
@flushright
  [default: 0]
@end flushright
@item --TOPC-slave-timeout@samp{=<int>}
@flushright
  [default: 1800 s]
@end flushright
@item --TOPC-trace@samp{=<int: 0/1/2>}
@flushright
  [trace (0: notrace, 1: trace, 2: user trace fncs, default: 2)]
@end flushright
@item --TOPC-procgroup@samp{=<string>}
@flushright
  [default: "./procgroup"]
@end flushright
@item --TOPC-safety@samp{=<int: 0..20>}
@flushright
  [default: 0]
@end flushright
@end table

@sp 1
@noindent
@emph{From @ref{Tracing Messages}.}
@table @code
@need 400
@item int TOPC_OPT_trace
@itemx void (*)(void *input) TOPC_OPT_trace_input
@itemx void (*)(void *input, void *output) TOPC_OPT_trace_result
@end table

@page

@node Example, Using a Different MPI with TOP-C, Summary, Top
@appendix Example @samp{TOP-C} Application

@cindex example TOP-C application

There are several example @samp{TOP-C} programs in the
@file{topc/examples} subdirectory.  We include one example in this
manual.  It does not contain any @code{UPDATE} actions, and therefore
illustrates only a trivial form of parallelism (with no interaction
among the slaves).  The @file{topc/examples} subdirectory should be
inspected for more sophisticated examples.
After understanding this example, you may also want to look at
@ref{Advanced Features}, or if you are parallelizing a sequential
program, then you may want to look at @ref{TOP-C Raw Interface}.

This program produces an array of 10,000,000 random integers in one pass,
and then finds the maximum value in a second pass.  It would be compiled
by: @command{topcc @var{MODE} @file{file.out}}, where @var{MODE} is one of
@code{--seq}, @code{--mpi}, or @code{--pthread}.  One can control the
number of slaves by executing:  @code{./a.out --TOPC-num-slaves=@var{num}}.

@example
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <topc.h>

#define MAX 2000000
#define INCR MAX/10 /* We assume INCR divides MAX exactly */

int array[MAX];
int idx;
int max_int;

TOPC_BUF GenerateTaskInput() @{
  int input_task;
  if (idx >= MAX) return NOTASK;
  input_task = idx;
  idx = idx + INCR;
  return TOPC_MSG( &input_task, sizeof(input_task) );
@}
TOPC_BUF DoTaskRandom( int *ignore ) @{
  int rand_int[INCR];
  int i;
  for ( i = 0; i < INCR; i++)
    rand_int[i] = rand();
  return TOPC_MSG( rand_int, INCR * sizeof(int) );
@}
TOPC_ACTION CheckTaskRandom( int *input, int rand_vals[] ) @{
  int curr_idx = *input;
  memcpy( array+curr_idx, rand_vals, INCR * sizeof(int) );
  return NO_ACTION;
@}

TOPC_BUF GenerateTaskInMax() @{
  int *input_task;
  if (idx >= MAX) return NOTASK;
  input_task = array + idx;
  idx = idx + INCR;
  return TOPC_MSG( input_task, INCR * sizeof(int) );
@}
TOPC_BUF DoTaskMax( int subarray[] ) @{
  int i;
  int max=0;
  for ( i = 0; i < INCR; i++)
    if ( subarray[i] > max )
      max = subarray[i];
  return TOPC_MSG( &max, sizeof(max) );
@}
TOPC_ACTION CheckTaskMax( int ignore[], int *output ) @{
  int curr_max = *output;
  if ( curr_max > max_int )
    max_int = curr_max;
  return NO_ACTION;
@}

int main( int argc, char **argv ) @{
  /* Set default to no trace; Override with:  ./a.out --TOPC-trace=1 */
  TOPC_OPT_trace = 0;
  TOPC_init( &argc, &argv );
  idx = 0; /* Initialize idx, and randomize values of array[] */
  TOPC_master_slave(GenerateTaskInput, DoTaskRandom, CheckTaskRandom,
                    NULL);
  if (TOPC_is_master())
    printf("Finished randomizing integers.\n");
  idx = 0; /* Re-initialize idx to 0, and find max. value in array[] */
  TOPC_master_slave( GenerateTaskInMax, DoTaskMax, CheckTaskMax, NULL );
  TOPC_finalize();
  printf("The maximum integer is:  %d\n", max_int);
  exit(0);
@}
@end example

@page

@node Using a Different MPI with TOP-C, Function Index, Example, Top
@appendix Using a Different @samp{MPI} with TOP-C

@samp{TOP-C} provides a built-in subset of MPI sufficient to run
distributed applications.  If you prefer to use a different implementation
of @samp{MPI} with @samp{TOP-C}, this note describes how to do so.
Examples for @samp{MPICH}, @samp{LAM} and @samp{IBM POE} are at the
end of this section.  You should re-configure and re-build @samp{TOP-C}
using the same C/C++ compiler as that of your chosen MPI.

First test a @samp{hello_world} MPI program
for your chosen MPI implementation to make sure that the
startup mechanism is well understood.

Many dialects of @samp{MPI} provide their own wrapper around
the C and C++ compiler.  For example, @samp{LAM MPI} provides @code{mpicc}.
If your dialect provides such a wrapper @code{mpicc}, then
do @code{./configure --with-mpi-cc=mpicc} and @code{make}.  There is a similar
configure flag, @code{--with-mpi-cxx}, for @samp{C++}.

If you do use such a wrapper, you should use the same C compiler for
the rest of @samp{TOP-C}.  Hence, if @code{mpicc} uses @code{cc},
then configure with @code{env CC=cc ./configure --with-mpi-cc=mpicc
--cache-file=/dev/null}.
In general, you can always specify a non-default C and C++ compiler by
specifying @code{CC=...} and @code{CXX=...}, respectively.

If your dialect does not provide such a wrapper, it is easy to create
one by modifying the shell script below for your site.
@example
#!/bin/sh
gcc -I/usr/local/include $* -L/usr/local/lib -lmpi
@end example

These wrappers will enable @command{topcc} and @command{topc++} to work,
but not @command{topc-config}.  If you also need @command{topc-config},
then you must modify @command{topc-config}.
Determine the libraries used by your dialect of MPI.
Then search for a string with @code{-ltopc-mpi} in
@file{.../topc/bin/topc-config},
and append to it your @samp{libmpi}.  For example,
append to @code{-ltopc-mpi} with @code{-L/usr/local/lib -lmpi}.

Finally, for many dialects of MPI, after compiling the MPI application,
they may also require a special command at runtime to execute,
such as @code{mpirun a.out}.
In such cases, your @samp{TOP-C} application must be treated similarly.

The following examples illustrate the configuration and use of
MPI for other MPI implementations using 2 slaves and 1 master.
@example
@group
# IBM POE/AIX:
  env CC=xlc CXX=xlC ./configure --with-mpi-cc=mpcc --with-mpi-cxx=mpCC
  make; cd bin; ./topcc --mpi -qcpluscmt ../examples/parfactor.c
  poe ./a.out 1234 --TOPC-stats -procs 3 -pgmmodel spmd
@end group
@end example

@example
@group
# MPICH/Linux:
  ./configure --with-mpi-cc=mpicc
  make; cd bin; ./topcc --mpi ../examples/parfactor.c
  mpirun -np 3 ./a.out --TOPC-stats 1234
@end group
@end example

@example
@group
# LAM/Linux:
  ./configure --with-mpi-cc=mpicc
  make; cd bin; ./topcc --mpi ../examples/parfactor.c
  mpirun -c 3 ./a.out -- --TOPC-stats 1234
@end group
@end example

@page

@node Function Index, Variable Index, Using a Different MPI with TOP-C, Top
@comment    node-name,         next,       previous, up
@unnumbered Function Index
@comment Run texindex for printed manual
@printindex fn

@node Variable Index, Concept Index, Function Index, Top
@comment    node-name,         next,       previous, up
@unnumbered Variable Index
@comment Run texindex for printed manual
@printindex vr

@page

@node     Concept Index,  , Variable Index, Top
@comment      node-name, next,       previous, up
@unnumbered Concept Index
@printindex cp

@shortcontents
@contents
@bye
